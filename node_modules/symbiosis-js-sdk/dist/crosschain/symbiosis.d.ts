import { StaticJsonRpcProvider } from '@ethersproject/providers';
import { Signer } from 'ethers';
import JSBI from 'jsbi';
import { ChainId } from '../constants';
import { Chain, Token, TokenAmount } from '../entities';
import { Bridging } from './bridging';
import { Aave, AdaRouter, AvaxRouter, BeefyVault, BenqiQiErc20, Bridge, CreamCErc20, CreamComptroller, Fabric, MetaRouter, MulticallRouter, NervePool, OneInchOracle, Portal, RenGatewayRegistryV2, RenMintGatewayV3, Synthesis, UniLikeRouter } from './contracts';
import { PendingRequest } from './pending';
import { RevertPending } from './revert';
import { Swapping } from './swapping';
import { ChainConfig, Config } from './types';
import { Zapping } from './zapping';
import { ZappingAave } from './zappingAave';
import { ZappingCream } from './zappingCream';
import { ZappingRenBTC } from './zappingRenBTC';
import { ZappingBeefy } from './zappingBeefy';
declare type ConfigName = 'testnet' | 'mainnet';
export declare class Symbiosis {
    providers: Map<ChainId, StaticJsonRpcProvider>;
    readonly config: Config;
    readonly clientId: string;
    constructor(config: ConfigName | Config, clientId: string);
    validateSwapAmounts(amount: TokenAmount): void;
    chains(): Chain[];
    newBridging(): Bridging;
    newSwapping(): Swapping;
    newRevertPending(request: PendingRequest): RevertPending;
    newZapping(): Zapping;
    newZappingAave(): ZappingAave;
    newZappingCream(): ZappingCream;
    newZappingRenBTC(): ZappingRenBTC;
    newZappingBeefy(): ZappingBeefy;
    getPendingRequests(address: string): Promise<PendingRequest[]>;
    getProvider(chainId: ChainId): StaticJsonRpcProvider;
    portal(chainId: ChainId, signer?: Signer): Portal;
    synthesis(chainId: ChainId, signer?: Signer): Synthesis;
    bridge(chainId: ChainId, signer?: Signer): Bridge;
    fabric(chainId: ChainId, signer?: Signer): Fabric;
    uniLikeRouter(chainId: ChainId, signer?: Signer): UniLikeRouter;
    avaxRouter(chainId: ChainId, signer?: Signer): AvaxRouter;
    adaRouter(chainId: ChainId, signer?: Signer): AdaRouter;
    nervePool(tokenIn: Token, tokenOut: Token, signer?: Signer): NervePool;
    getNerveTokenIndexes(chainId: ChainId, tokenA: string, tokenB: string): number[];
    nervePoolByAddress(address: string, chainId: ChainId, signer?: Signer): NervePool;
    creamCErc20ByAddress(address: string, chainId: ChainId, signer?: Signer): CreamCErc20;
    benqiQiErc20ByAddress(address: string, chainId: ChainId, signer?: Signer): BenqiQiErc20;
    creamComptroller(chainId: ChainId, signer?: Signer): CreamComptroller;
    aavePool(chainId: ChainId, signer?: Signer): Aave;
    multicallRouter(chainId: ChainId, signer?: Signer): MulticallRouter;
    metaRouter(chainId: ChainId, signer?: Signer): MetaRouter;
    oneInchOracle(chainId: ChainId, signer?: Signer): OneInchOracle;
    renRenGatewayRegistry(chainId: ChainId, signer?: Signer): RenGatewayRegistryV2;
    renMintGatewayByAddress(address: string, chainId: ChainId, signer?: Signer): RenMintGatewayV3;
    beefyVault(address: string, chainId: ChainId, signer?: Signer): BeefyVault;
    stables(): Token[];
    findTransitStable(chainId: ChainId): Token | undefined;
    findStable(address: string, chainId: ChainId, chainFromId?: ChainId): Token | undefined;
    getRepresentation(token: Token, chainId: ChainId): Promise<Token | undefined>;
    getBridgeFee({ calldata, receiveSide, chainIdFrom, chainIdTo, }: {
        calldata: string;
        receiveSide: string;
        chainIdFrom: ChainId;
        chainIdTo: ChainId;
    }): Promise<JSBI>;
    filterBlockOffset(chainId: ChainId): number;
    getFromBlockWithOffset(chainId: ChainId): Promise<number>;
    dexFee(chainId: ChainId): number;
    chainConfig(chainId: ChainId): ChainConfig;
    transitStable(chainId: ChainId): Token;
    isTransitStable(token: Token): boolean;
}
export {};
