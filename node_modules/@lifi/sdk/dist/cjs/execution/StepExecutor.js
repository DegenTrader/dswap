"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StepExecutor = void 0;
const bridge_execute_1 = require("./bridges/bridge.execute");
const swap_execute_1 = require("./exchanges/swap.execute");
const switchChain_1 = require("./switchChain");
const defaultExecutionHaltSettings = {
    allowUpdates: true,
};
class StepExecutor {
    constructor(statusManager, settings) {
        this.swapExecutionManager = new swap_execute_1.SwapExecutionManager();
        this.bridgeExecutionManager = new bridge_execute_1.BridgeExecutionManager();
        this.executionStopped = false;
        this.stopStepExecution = (settings) => {
            const haltingSettings = Object.assign(Object.assign({}, defaultExecutionHaltSettings), settings);
            this.swapExecutionManager.setShouldContinue(false);
            this.bridgeExecutionManager.setShouldContinue(false);
            this.statusManager.setShouldUpdate(haltingSettings.allowUpdates);
            this.executionStopped = true;
        };
        this.executeStep = (signer, step) => __awaiter(this, void 0, void 0, function* () {
            // check if signer is for correct chain
            const updatedSigner = yield (0, switchChain_1.switchChain)(signer, this.statusManager, step, this.settings.switchChainHook, !this.executionStopped);
            if (!updatedSigner) {
                // chain switch was not successful, stop execution here
                return step;
            }
            signer = updatedSigner;
            switch (step.type) {
                case 'lifi':
                case 'cross':
                    yield this.executeCross(signer, step);
                    break;
                case 'swap':
                    yield this.executeSwap(signer, step);
                    break;
                default:
                    throw new Error('Unsupported step type.');
            }
            return step;
        });
        this.executeSwap = (signer, step) => __awaiter(this, void 0, void 0, function* () {
            const swapParams = {
                signer,
                step,
                settings: this.settings,
                statusManager: this.statusManager,
            };
            return yield this.swapExecutionManager.execute(swapParams);
        });
        this.executeCross = (signer, step) => __awaiter(this, void 0, void 0, function* () {
            const crossParams = {
                signer,
                step,
                settings: this.settings,
                statusManager: this.statusManager,
            };
            return yield this.bridgeExecutionManager.execute(crossParams);
        });
        this.statusManager = statusManager;
        this.settings = settings;
    }
}
exports.StepExecutor = StepExecutor;
