"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BridgeExecutionManager = void 0;
const ethers_1 = require("ethers");
const ApiService_1 = __importDefault(require("../../services/ApiService"));
const ChainsService_1 = __importDefault(require("../../services/ChainsService"));
const errors_1 = require("../../utils/errors");
const getProvider_1 = require("../../utils/getProvider");
const parseError_1 = require("../../utils/parseError");
const utils_1 = require("../../utils/utils");
const allowance_execute_1 = require("../allowance.execute");
const balanceCheck_execute_1 = require("../balanceCheck.execute");
const stepComparison_1 = require("../stepComparison");
const switchChain_1 = require("../switchChain");
const utils_2 = require("../utils");
class BridgeExecutionManager {
    constructor() {
        this.shouldContinue = true;
        this.setShouldContinue = (val) => {
            this.shouldContinue = val;
        };
        this.execute = ({ signer, step, statusManager, settings, }) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const { action, estimate } = step;
            step.execution = statusManager.initExecutionObject(step);
            const chainsService = ChainsService_1.default.getInstance();
            const fromChain = yield chainsService.getChainById(action.fromChainId);
            const toChain = yield chainsService.getChainById(action.toChainId);
            // STEP 1: Check Allowance ////////////////////////////////////////////////
            // approval still needed?
            const oldCrossProcess = step.execution.process.find((p) => p.type === 'CROSS_CHAIN');
            if (!(oldCrossProcess === null || oldCrossProcess === void 0 ? void 0 : oldCrossProcess.txHash)) {
                if (action.fromToken.address !== ethers_1.constants.AddressZero) {
                    // Check Token Approval only if fromToken is not the native token => no approval needed in that case
                    yield (0, allowance_execute_1.checkAllowance)(signer, step, fromChain, action.fromToken, action.fromAmount, estimate.approvalAddress, statusManager, settings.infiniteApproval, this.shouldContinue);
                }
            }
            // STEP 2: Get Transaction ////////////////////////////////////////////////
            let crossChainProcess = statusManager.findOrCreateProcess('CROSS_CHAIN', step);
            try {
                let tx;
                if (crossChainProcess.txHash) {
                    // load exiting transaction
                    tx = yield (0, getProvider_1.getProvider)(signer).getTransaction(crossChainProcess.txHash);
                }
                else {
                    // check balance
                    yield (0, balanceCheck_execute_1.balanceCheck)(signer, step);
                    // create new transaction
                    const personalizedStep = yield (0, utils_1.personalizeStep)(signer, step);
                    const updatedStep = yield ApiService_1.default.getStepTransaction(personalizedStep);
                    step = Object.assign(Object.assign({}, (yield (0, stepComparison_1.stepComparison)(statusManager, personalizedStep, updatedStep, settings.acceptSlippageUpdateHook, this.shouldContinue))), { execution: step.execution });
                    const { transactionRequest } = step;
                    if (!transactionRequest) {
                        throw new errors_1.TransactionError(errors_1.LifiErrorCode.TransactionUnprepared, 'Unable to prepare transaction.');
                    }
                    // STEP 3: Send Transaction ///////////////////////////////////////////////
                    // make sure that chain is still correct
                    const updatedSigner = yield (0, switchChain_1.switchChain)(signer, statusManager, step, settings.switchChainHook, this.shouldContinue);
                    if (!updatedSigner) {
                        // chain switch was not successful, stop execution here
                        return step.execution;
                    }
                    signer = updatedSigner;
                    crossChainProcess = statusManager.updateProcess(step, crossChainProcess.type, 'ACTION_REQUIRED');
                    if (!this.shouldContinue) {
                        return step.execution;
                    }
                    tx = yield signer.sendTransaction(transactionRequest);
                    // STEP 4: Wait for Transaction ///////////////////////////////////////////
                    crossChainProcess = statusManager.updateProcess(step, crossChainProcess.type, 'PENDING', {
                        txHash: tx.hash,
                        txLink: fromChain.metamask.blockExplorerUrls[0] + 'tx/' + tx.hash,
                    });
                }
                yield tx.wait();
            }
            catch (e) {
                if (e.code === 'TRANSACTION_REPLACED' && e.replacement) {
                    crossChainProcess = statusManager.updateProcess(step, crossChainProcess.type, 'PENDING', {
                        txHash: e.replacement.hash,
                        txLink: fromChain.metamask.blockExplorerUrls[0] +
                            'tx/' +
                            e.replacement.hash,
                    });
                }
                else {
                    const error = yield (0, parseError_1.parseError)(e, step, crossChainProcess);
                    crossChainProcess = statusManager.updateProcess(step, crossChainProcess.type, 'FAILED', {
                        error: {
                            message: error.message,
                            htmlMessage: error.htmlMessage,
                            code: error.code,
                        },
                    });
                    statusManager.updateExecution(step, 'FAILED');
                    throw error;
                }
            }
            crossChainProcess = statusManager.updateProcess(step, crossChainProcess.type, 'DONE');
            // STEP 5: Wait for Receiver //////////////////////////////////////
            let receivingChainProcess = statusManager.findOrCreateProcess('RECEIVING_CHAIN', step, 'PENDING');
            let statusResponse;
            try {
                if (!crossChainProcess.txHash) {
                    throw new Error('Transaction hash is undefined.');
                }
                statusResponse = yield (0, utils_2.waitForReceivingTransaction)(crossChainProcess.txHash, statusManager, receivingChainProcess.type, step);
            }
            catch (e) {
                receivingChainProcess = statusManager.updateProcess(step, receivingChainProcess.type, 'FAILED', {
                    error: {
                        code: errors_1.LifiErrorCode.TransactionFailed,
                        message: 'Failed while waiting for receiving chain.',
                        htmlMessage: (0, parseError_1.getTransactionFailedMessage)(step, crossChainProcess.txLink),
                    },
                });
                statusManager.updateExecution(step, 'FAILED');
                throw e;
            }
            receivingChainProcess = statusManager.updateProcess(step, receivingChainProcess.type, 'DONE', {
                substatus: statusResponse.substatus,
                substatusMessage: statusResponse.substatusMessage ||
                    (0, utils_2.getSubstatusMessage)(statusResponse.status, statusResponse.substatus),
                txHash: (_a = statusResponse.receiving) === null || _a === void 0 ? void 0 : _a.txHash,
                txLink: toChain.metamask.blockExplorerUrls[0] +
                    'tx/' +
                    ((_b = statusResponse.receiving) === null || _b === void 0 ? void 0 : _b.txHash),
            });
            statusManager.updateExecution(step, 'DONE', {
                fromAmount: statusResponse.sending.amount,
                toAmount: (_c = statusResponse.receiving) === null || _c === void 0 ? void 0 : _c.amount,
                toToken: (_d = statusResponse.receiving) === null || _d === void 0 ? void 0 : _d.token,
                gasUsed: statusResponse.sending.gasUsed,
                gasPrice: statusResponse.sending.gasPrice,
            });
            // DONE
            return step.execution;
        });
    }
}
exports.BridgeExecutionManager = BridgeExecutionManager;
