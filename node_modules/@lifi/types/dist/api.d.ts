import { BridgeDefinition, Chain, ChainId, ExchangeDefinition, Step, Token } from '.';
import { ToolError } from './apiErrors';
import { Bridge } from './bridges';
import { Exchange, ExchangeAggregator } from './exchanges';
export declare const Orders: readonly ["RECOMMENDED", "FASTEST", "CHEAPEST", "SAFEST"];
export declare type Order = typeof Orders[number];
export interface AllowDenyPrefer {
    allow?: string[];
    deny?: string[];
    prefer?: string[];
}
export interface RouteOptions {
    order?: Order;
    slippage?: number;
    infiniteApproval?: boolean;
    allowSwitchChain?: boolean;
    integrator?: string;
    referrer?: string;
    bridges?: AllowDenyPrefer;
    exchanges?: AllowDenyPrefer;
    fee?: number;
}
export interface RoutesRequest {
    fromChainId: number;
    fromAmount: string;
    fromTokenAddress: string;
    fromAddress?: string;
    toChainId: number;
    toTokenAddress: string;
    toAddress?: string;
    options?: RouteOptions;
}
export interface Route {
    id: string;
    fromChainId: number;
    fromAmountUSD: string;
    fromAmount: string;
    fromToken: Token;
    fromAddress?: string;
    toChainId: number;
    toAmountUSD: string;
    toAmount: string;
    toAmountMin: string;
    toToken: Token;
    toAddress?: string;
    gasCostUSD?: string;
    containsSwitchChain?: boolean;
    infiniteApproval?: boolean;
    steps: Step[];
    tags?: Order[];
}
export interface RoutesResponse {
    routes: Route[];
    errors: ToolError[];
}
export declare type PossibilityTopic = 'chains' | 'tokens' | 'bridges' | 'exchanges';
export interface PossibilitiesRequest {
    chains?: number[];
    bridges?: AllowDenyPrefer;
    exchanges?: AllowDenyPrefer;
    include?: PossibilityTopic[];
}
export interface PossibilitiesResponse {
    chains?: Chain[];
    tokens?: Token[];
    bridges?: BridgeDefinition[];
    exchanges?: ExchangeDefinition[];
}
export interface GetTokenRequest {
    chain: number | string;
    token: string;
}
export interface ToolConfiguration {
    allowBridges?: string[];
    denyBridges?: string[];
    preferBridges?: string[];
    allowExchanges?: string[];
    denyExchanges?: string[];
    preferExchanges?: string[];
}
export interface QuoteRequest extends ToolConfiguration {
    fromChain: number | string;
    fromToken: string;
    fromAddress: string;
    fromAmount: string;
    toChain: number | string;
    toToken: string;
    toAddress?: string;
    order?: Order;
    slippage?: number | string;
    integrator?: string;
    referrer?: string;
    fee?: number | string;
}
export interface ContractCallQuoteRequest extends ToolConfiguration {
    fromChain: number | string;
    fromToken: string;
    fromAddress: string;
    toChain: number | string;
    toToken: string;
    toAmount: string;
    toContractAddress: string;
    toContractCallData: string;
    toContractGasLimit: string;
    toApprovalAddress?: string;
    toFallbackAddress?: string;
    contractOutputsToken?: string;
    slippage?: number | string;
    integrator?: string;
    referrer?: string;
    fee?: number | string;
}
export interface ContractCallQuotesRequest extends ToolConfiguration {
    fromChain: number | string;
    fromToken: string;
    fromAddress: string;
    toChain: number | string;
    toFallbackAddress?: string;
    toContractCalls: {
        sendingAmount: string;
        sendingToken: string;
        receivingToken: string;
        contractAddress: string;
        approvalAddress?: string;
        callData: string;
        gasLimit: string;
    }[];
    order?: Order;
    slippage?: number | string;
    integrator?: string;
    referrer?: string;
}
export interface ConnectionsRequest extends ToolConfiguration {
    fromChain?: number | string;
    fromToken?: string;
    toChain?: number | string;
    toToken?: string;
}
export interface Connection {
    fromChainId: number;
    toChainId: number;
    fromTokens: Token[];
    toTokens: Token[];
}
export interface ConnectionsResponse {
    connections: Connection[];
}
export interface GetStatusRequest {
    txHash: string;
    bridge?: string;
    fromChain: number | string;
    toChain: number | string;
}
export interface TransactionInfo {
    txHash: string;
    txLink?: string;
    amount?: string;
    token?: Token;
    chainId?: ChainId;
    gasPrice?: string;
    gasUsed?: string;
}
declare const _StatusMessage: readonly ["NOT_FOUND", "INVALID", "PENDING", "DONE", "FAILED"];
export declare type StatusMessage = typeof _StatusMessage[number];
declare const _SubstatusPending: readonly ["WAIT_SOURCE_CONFIRMATIONS", "WAIT_DESTINATION_TRANSACTION", "BRIDGE_NOT_AVAILABLE", "CHAIN_NOT_AVAILABLE", "NOT_PROCESSABLE_REFUND_NEEDED", "REFUND_IN_PROGRESS", "UNKNOWN_ERROR"];
export declare type SubstatusPending = typeof _SubstatusPending[number];
declare const _SubstatusDone: readonly ["COMPLETED", "PARTIAL", "REFUNDED"];
export declare type SubstatusDone = typeof _SubstatusDone[number];
export declare type Substatus = SubstatusPending | SubstatusDone;
export declare const isSubstatusPending: (substatus: Substatus) => substatus is "WAIT_SOURCE_CONFIRMATIONS" | "WAIT_DESTINATION_TRANSACTION" | "BRIDGE_NOT_AVAILABLE" | "CHAIN_NOT_AVAILABLE" | "NOT_PROCESSABLE_REFUND_NEEDED" | "REFUND_IN_PROGRESS" | "UNKNOWN_ERROR";
export declare const isSubstatusDone: (substatus: Substatus) => substatus is "COMPLETED" | "PARTIAL" | "REFUNDED";
export interface StatusInformation {
    status: StatusMessage;
    substatus?: Substatus;
    substatusMessage?: string;
}
export interface StatusResponse extends StatusInformation {
    sending: TransactionInfo;
    receiving?: TransactionInfo;
    tool?: string;
}
export interface ChainsResponse {
    chains: Chain[];
}
export interface ToolsRequest {
    chains?: ChainId[];
}
export declare type ToolsResponse = {
    exchanges: Pick<Exchange | ExchangeAggregator, 'key' | 'name' | 'logoURI'>[];
    bridges: Pick<Bridge, 'key' | 'name' | 'logoURI'>[];
};
export declare type TokensRequest = {
    chains?: ChainId[];
};
export declare type TokensResponse = {
    tokens: {
        [chainId: number]: Token[];
    };
};
export declare type RequestOptions = {
    signal?: AbortSignal;
};
export declare class LifiAPI {
    getRoutes(request: RoutesRequest): Promise<RoutesResponse>;
    getPossibilities(request?: PossibilitiesRequest): Promise<PossibilitiesResponse>;
    updateRoute(route: Route): Promise<Route>;
    getStepTransaction(step: Step): Promise<Step>;
    getToken(request: GetTokenRequest): Promise<Token>;
    getTokens(request: TokensRequest): Promise<TokensResponse>;
    getQuote(request: QuoteRequest): Promise<Step>;
    getContractCallQuote(request: ContractCallQuoteRequest): Promise<Step>;
    getContractCallQuotes(request: ContractCallQuotesRequest): Promise<Step>;
    getStatus(request: GetStatusRequest): Promise<StatusResponse>;
    getTools(request: ToolsRequest): Promise<ToolsResponse>;
    getChains(): ChainsResponse;
    getConnections(request: ConnectionsRequest): Promise<ConnectionsResponse>;
}
export {};
