import { RenVMProvider } from "@renproject/provider";
import { Chain, RenNetwork, RenNetworkString, RenVMShard } from "@renproject/utils";
import { Gateway } from "./gateway";
import { GatewayTransaction } from "./gatewayTransaction";
import { GatewayParams, TransactionParams } from "./params";
import { RenJSConfig } from "./utils/config";
import { GatewayFees } from "./utils/fees";
export { Gateway } from "./gateway";
export { GatewayTransaction } from "./gatewayTransaction";
export { GatewayFees } from "./utils/fees";
export { RenVMTxSubmitter } from "./renVMTxSubmitter";
/**
 * This is the main exported class from `@renproject/ren`.
 *
 * ```typescript
 * import RenJS from "@renproject/ren";
 * ```
 *
 * By default, RenJS will connect to the RenVM mainnet network. To connect
 * to `testnet` or to configure a custom connection, RenJS takes an optional
 * provider object. See the [[constructor]] for more details.
 *
 * ```typescript
 * new RenJS(); // Same as `new RenJS("mainnet");`
 * new RenJS("testnet");
 * new RenJS(custom provider object);
 * ```
 *
 * It then exposes two main functions:
 * 1. [[gateway]] - for initiating new cross-chain transfers.
 * 2. [[gatewayTransaction]] - for continuing existing cross-chain transfers.
 *
 * Also see:
 * 1. [[getFees]] - for estimating the fees that will be incurred by minting or
 * burning.
 * 2. [[defaultTransactionHandler]] - a static function for handling
 * GatewayTransactions.
 *
 */
export declare class RenJS {
    /**
     * `Networks` exposes the network options that can be passed in to the RenJS
     * constructor. `Networks.Mainnet` resolves to the string `"mainnet"`.
     */
    static Networks: typeof RenNetwork;
    /**
     * `RenJS.defaultTransactionHandler` can be passed as a transaction callback when
     * minting. It will handle submitting to RenVM and then to the mint-chain,
     * as long as a valid provider for the mint-chain is given.
     *
     * This is not recommended for front-ends, since it may trigger a wallet
     * pop-up unexpectedly when the mint is ready to be submitted.
     *
     * ```ts
     * gateway.on("transaction", RenJS.defaultTransactionHandler);
     * ```
     */
    static defaultTransactionHandler: ((tx: GatewayTransaction<{
        chain: string;
    }>) => Promise<void>) & {
        withRetries: (newRetries: number) => void;
    };
    /**
     * In order to add support for chains, `withChains` must be called,
     * providing chain handlers that implement the Chain interface.
     */
    readonly chains: {
        [chain: string]: Chain;
    };
    /**
     * RenVM provider exposing `sendMessage` and other helper functions for
     * interacting with RenVM. See [[AbstractRenVMProvider]].
     *
     * ```ts
     * renJS.renVM.sendMessage("ren_queryNumPeers", {});
     * ```
     */
    readonly provider: RenVMProvider;
    private readonly _config;
    /**
     * Accepts the name of a network, or a network object.
     *
     * @param providerOrNetwork Provider the name of a RenNetwork or a RenVM
     * provider instance.
     * @param config Provider RenJS config such as a logger.
     */
    constructor(providerOrNetwork?: RenNetwork | RenNetworkString | RenVMProvider | string, config?: RenJSConfig);
    /**
     * Register one or more chain handlers, each implementing the Chain
     * interface. By default, RenJS has no chain handlers, so this is required
     * for all chains being bridged from or to.
     *
     * Note that any Gateway or GatewayTransaction instance that has already
     * been created will continue pointing to the chain handler at the time it
     * was created.
     */
    withChains: <T extends Chain<any, any>[]>(...chains: T) => this;
    withChain: <T extends Chain<any, any>[]>(...chains: T) => this;
    /**
     * Return the chain handler previously added using [[withChains]].
     */
    getChain: <T extends Chain<any, any>>(name: string) => T;
    /**
     * Calculate the RenVM and blockchain fees for a transaction.
     *
     * @example
     * renJS.getFees({
     *   asset: "BTC",
     *   from: "Bitcoin",
     *   to: "Ethereum",
     * })
     *
     * @example
     * renJS.getFees({
     *   asset: "BTC",
     *   from: bitcoin.GatewayAddress(),
     *   to: ethereum.Account(),
     * })
     */
    getFees: ({ asset, from, to, }: {
        asset: string;
        from: string | {
            chain: string;
            txConfig?: any;
        };
        to: string | {
            chain: string;
            txConfig?: any;
        };
    }) => Promise<GatewayFees>;
    /**
     * Return the recommended shard for processing transactions of the specified
     * asset.
     */
    readonly selectShard: (asset: string) => Promise<RenVMShard>;
    /**
     * `gateway` initiates a new Gateway for bridging an asset between two
     * chains.
     *
     * See [[Gateway]] for all the options that can be set.
     *
     * @example
     * const gateway = renJS.gateway({
     *     asset: "BTC",
     *     from: bitcoin.GatewayAddress(),
     *     to: ethereum.Account(),
     * });
     * ```
     *
     * @param params See [[GatewayParams]]. This is a serializable object,
     * allowing gateways to be re-created.
     * @param config Optional RenJS config, such as a logger.
     */
    readonly gateway: <FromPayload extends {
        chain: string;
        txConfig?: any;
    } = any, ToPayload extends {
        chain: string;
        txConfig?: any;
    } = any>(params: GatewayParams<FromPayload, ToPayload>, config?: RenJSConfig) => Promise<Gateway<FromPayload, ToPayload>>;
    /**
     * `gatewayTransaction` allows you to re-create a transaction emitted
     * by `gateway.on("transaction", (tx) => {...})`.
     *
     * @param params The same type as `tx.params` on an emitted `tx`. This is a
     * serializable object.
     * @param config Optional RenJS config, such as a logger.
     */
    readonly gatewayTransaction: <ToPayload extends {
        chain: string;
        txConfig?: any;
    } = {
        chain: string;
    }>(params: TransactionParams<ToPayload>, config?: RenJSConfig) => Promise<GatewayTransaction<ToPayload>>;
}
export default RenJS;
//# sourceMappingURL=index.d.ts.map