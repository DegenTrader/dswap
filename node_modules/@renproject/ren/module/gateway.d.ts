import { RenVMProvider } from "@renproject/provider";
import { Chain, ChainTransactionProgress, InputChainTransaction, InputType, OutputType, TxSubmitter, TxWaiter } from "@renproject/utils";
import { OrderedMap } from "immutable";
import { GatewayTransaction } from "./gatewayTransaction";
import { GatewayParams } from "./params";
import { defaultRenJSConfig, RenJSConfig } from "./utils/config";
import { GatewayFees } from "./utils/fees";
import { TransactionEmitter } from "./utils/transactionEmitter";
/**
 * A Gateway allows moving funds through RenVM. Its defined by the asset being
 * moved, an origin chain and a target chain. For each of these chains, a
 * payload can be specified, allowing for more complex bridgings involving
 * contract interactions.
 *
 * A Gateway will be of one of two types - a deposit gateway, requiring users
 * to send funds to a gateway address, or a contract gateway, requiring users to
 * submit a specific transaction. For example, when moving BTC from Bitcoin
 * to Ethereum, the user will have to send BTC to a Bitcoin address (the gateway
 * address). When moving DAI from Ethereum to Polygon, the user will have to
 * submit a transaction locking the DAI on Ethereum.
 *
 * When these deposits or transactions are initiated, a GatewayTransaction
 * instance is created.
 */
export declare class Gateway<FromPayload extends {
    chain: string;
    txConfig?: any;
} = any, ToPayload extends {
    chain: string;
    txConfig?: any;
} = any> {
    /**
     * The parameters passed in when creating the gateway. This can be
     * serialized and used to re-create the gateway. If the parameters passed in
     * to `renJS.gateway` didn't include a `shard` value, it will be set here.
     */
    readonly params: GatewayParams<FromPayload, ToPayload>;
    /** The chain handler for the origin chain.  */
    readonly fromChain: Chain;
    /** The chain handler for the target chain. */
    readonly toChain: Chain;
    /** The RenVM provider handles communicating with the RenVM network. */
    readonly provider: RenVMProvider;
    /** RenJS config - can be used to set a logger to be used by the gateway. */
    readonly config: typeof defaultRenJSConfig & RenJSConfig;
    /**
     * The generated gateway address for the lock-chain.
     */
    gatewayAddress: string | undefined;
    /**
     * A map of transactions that are required to be submitted before
     * `gateway.in` can be called.
     */
    inSetup: {
        [key: string]: TxSubmitter | TxWaiter;
    };
    /** The input chain transaction - not defined for deposit gateways. */
    in: TxSubmitter<ChainTransactionProgress, FromPayload["txConfig"]> | TxWaiter | undefined;
    /**
     * Deposits represents the lock deposits that have been detected so far.
     */
    transactions: OrderedMap<string, GatewayTransaction<ToPayload> | Promise<GatewayTransaction<ToPayload>>>;
    /** The event emitter that handles "transaction" events. */
    eventEmitter: TransactionEmitter<ToPayload>;
    private _selector;
    /** The RenVM contract selector. */
    get selector(): string;
    private _gHash;
    /** The gateway hash, a hash of the payload, selector, to and nonce. */
    get gHash(): Uint8Array;
    private _pHash;
    /** The payload hash, a hash of the payload. */
    get pHash(): Uint8Array;
    private _fees;
    /** The RenVM and blockchain fees of the gateway. */
    get fees(): GatewayFees;
    private _inputType;
    /** The input type of the transaction, either a lock or a burn. */
    get inputType(): InputType;
    private _outputType;
    /** The output type of the transaction, either a mint or a release. */
    get outputType(): OutputType;
    private _inConfirmationTarget;
    /** The number of confirmations required for `gateway.in`. */
    get inConfirmationTarget(): number;
    /**
     * @hidden - should be created using [[RenJS.lockAndMint]] instead.
     */
    constructor(renVM: RenVMProvider, fromChain: Chain, toChain: Chain, params: GatewayParams<FromPayload, ToPayload>, config?: RenJSConfig);
    /**
     * @hidden - Called automatically when calling [[RenJS.gateway]]. It has
     * been split from the constructor because it is asynchronous.
     */
    initialize: () => Promise<Gateway<FromPayload, ToPayload>>;
    private addTransaction;
    private removeTransaction;
    /**
     * `processDeposit` allows you to manually provide the details of a deposit
     * and returns a [[GatewayTransaction]] object.
     *
     * @param inputTx The deposit details in the format defined by the
     * LockChain. This should be the same format as `deposit.depositDetails` for
     * a deposit returned from `.on("transaction", ...)`.
     *
     * ```ts
     * const gatewayTransaction = await gateway
     *   .processDeposit({
     *      chain: "Ethereum",
     *      txHash: "0xef90...",
     *      txid: "752...",
     *      txindex: "0",
     *      amount: "1",
     *   })
     * ```
     * @category Main
     */
    processDeposit: (inputTx: InputChainTransaction) => Promise<GatewayTransaction<ToPayload>>;
    /**
     * Listen to "transaction" events, registering a callback that will be
     * called for all previous transactions and for any future transaction.
     *
     * To remove the listener, call `gateway.eventEmitter.removeListener` or
     * `gateway.eventEmitter.removeAllListeners`.
     */
    on<Event extends "transaction">(event: Event, callback: Event extends "transaction" ? (deposit: GatewayTransaction<ToPayload>) => void : never): this;
    /** PRIVATE METHODS */
    private _defaultGetter;
    /**
     * Internal method that fetches deposits to the gateway address. If there
     * are no listeners to the "transaction" event, then it pauses fetching
     * deposits.
     */
    private _watchForDeposits;
}
//# sourceMappingURL=gateway.d.ts.map