var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ChainTransactionStatus, ErrorWithCode, RenJSError, utils, } from "@renproject/utils";
const chainTransactionHandler = (tx, { retries = 1, } = {}) => __awaiter(void 0, void 0, void 0, function* () {
    while (true) {
        switch (tx.progress.status) {
            case ChainTransactionStatus.Ready:
                if (!tx.submit) {
                    throw new ErrorWithCode(`${tx.chain} transaction doesn't have a submit handler.`, RenJSError.PARAMETER_ERROR);
                }
                yield utils.tryNTimes((i) => __awaiter(void 0, void 0, void 0, function* () {
                    try {
                        tx.submit && (yield tx.submit());
                    }
                    catch (error) {
                        // Log error every 10 attempts.
                        if ((i + 1) % 10 === 0) {
                            console.error(error);
                        }
                        throw error;
                    }
                }), retries);
                break;
            case ChainTransactionStatus.Confirming:
                yield utils.tryNTimes((i) => __awaiter(void 0, void 0, void 0, function* () {
                    try {
                        yield tx.wait();
                    }
                    catch (error) {
                        // Log error every 10 attempts.
                        if ((i + 1) % 10 === 0) {
                            console.error(error);
                        }
                        throw error;
                    }
                }), retries);
                break;
            case ChainTransactionStatus.Reverted:
                throw new ErrorWithCode(`${tx.chain} transaction reverted${tx.progress.revertReason
                    ? ` with reason: ${tx.progress.revertReason}`
                    : ``}`, tx.chain === "RenVM"
                    ? RenJSError.RENVM_TRANSACTION_REVERTED
                    : RenJSError.CHAIN_TRANSACTION_REVERTED);
            case ChainTransactionStatus.Done:
                return;
        }
    }
});
/**
 * See [[RenJS.defaultTransactionHandler]].
 */
const createTransactionHandler = (retries = -1) => {
    const fn = (tx) => __awaiter(void 0, void 0, void 0, function* () {
        yield chainTransactionHandler(tx.in, { retries });
        yield chainTransactionHandler(tx.renVM, { retries });
        for (const setupKey of Object.keys(tx.outSetup || {})) {
            yield chainTransactionHandler(tx.outSetup[setupKey], { retries });
        }
        yield chainTransactionHandler(tx.out, { retries });
    });
    fn.withRetries = (newRetries) => createTransactionHandler(newRetries);
    return fn;
};
/**
 * See [[RenJS.defaultTransactionHandler]].
 */
export const defaultTransactionHandler = createTransactionHandler();
//# sourceMappingURL=defaultTransactionHandler.js.map