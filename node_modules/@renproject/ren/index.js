"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RenJS = exports.RenVMTxSubmitter = exports.GatewayTransaction = exports.Gateway = void 0;
const provider_1 = require("@renproject/provider");
const utils_1 = require("@renproject/utils");
const gateway_1 = require("./gateway");
const gatewayTransaction_1 = require("./gatewayTransaction");
const defaultTransactionHandler_1 = require("./utils/defaultTransactionHandler");
const fees_1 = require("./utils/fees");
var gateway_2 = require("./gateway");
Object.defineProperty(exports, "Gateway", { enumerable: true, get: function () { return gateway_2.Gateway; } });
var gatewayTransaction_2 = require("./gatewayTransaction");
Object.defineProperty(exports, "GatewayTransaction", { enumerable: true, get: function () { return gatewayTransaction_2.GatewayTransaction; } });
var renVMTxSubmitter_1 = require("./renVMTxSubmitter");
Object.defineProperty(exports, "RenVMTxSubmitter", { enumerable: true, get: function () { return renVMTxSubmitter_1.RenVMTxSubmitter; } });
/**
 * This is the main exported class from `@renproject/ren`.
 *
 * ```typescript
 * import RenJS from "@renproject/ren";
 * ```
 *
 * By default, RenJS will connect to the RenVM mainnet network. To connect
 * to `testnet` or to configure a custom connection, RenJS takes an optional
 * provider object. See the [[constructor]] for more details.
 *
 * ```typescript
 * new RenJS(); // Same as `new RenJS("mainnet");`
 * new RenJS("testnet");
 * new RenJS(custom provider object);
 * ```
 *
 * It then exposes two main functions:
 * 1. [[gateway]] - for initiating new cross-chain transfers.
 * 2. [[gatewayTransaction]] - for continuing existing cross-chain transfers.
 *
 * Also see:
 * 1. [[getFees]] - for estimating the fees that will be incurred by minting or
 * burning.
 * 2. [[defaultTransactionHandler]] - a static function for handling
 * GatewayTransactions.
 *
 */
class RenJS {
    /**
     * Accepts the name of a network, or a network object.
     *
     * @param providerOrNetwork Provider the name of a RenNetwork or a RenVM
     * provider instance.
     * @param config Provider RenJS config such as a logger.
     */
    constructor(providerOrNetwork = utils_1.RenNetwork.Mainnet, config) {
        /**
         * In order to add support for chains, `withChains` must be called,
         * providing chain handlers that implement the Chain interface.
         */
        this.chains = {};
        /**
         * Register one or more chain handlers, each implementing the Chain
         * interface. By default, RenJS has no chain handlers, so this is required
         * for all chains being bridged from or to.
         *
         * Note that any Gateway or GatewayTransaction instance that has already
         * been created will continue pointing to the chain handler at the time it
         * was created.
         */
        this.withChains = (...chains) => {
            for (const chain of chains) {
                this.chains[chain.chain] = chain;
            }
            return this;
        };
        this.withChain = this.withChains;
        /**
         * Return the chain handler previously added using [[withChains]].
         */
        this.getChain = (name) => {
            (0, utils_1.assertType)("string", { name });
            if (!this.chains[name]) {
                throw utils_1.ErrorWithCode.updateError(new Error(`Chain ${name} not found. (Must call 'renJS.withChains(${name.toLowerCase()})')`), utils_1.RenJSError.PARAMETER_ERROR);
            }
            return this.chains[name];
        };
        /**
         * Calculate the RenVM and blockchain fees for a transaction.
         *
         * @example
         * renJS.getFees({
         *   asset: "BTC",
         *   from: "Bitcoin",
         *   to: "Ethereum",
         * })
         *
         * @example
         * renJS.getFees({
         *   asset: "BTC",
         *   from: bitcoin.GatewayAddress(),
         *   to: ethereum.Account(),
         * })
         */
        this.getFees = async ({ asset, from, to, }) => {
            const fromChain = this.getChain(typeof from === "string" ? from : from.chain);
            const toChain = this.getChain(typeof to === "string" ? to : to.chain);
            if (!((await fromChain.isLockAsset(asset)) ||
                ((0, utils_1.isContractChain)(fromChain) &&
                    (await fromChain.isMintAsset(asset))))) {
                throw utils_1.ErrorWithCode.updateError(new Error(`Asset not supported by chain ${fromChain.chain}.`), utils_1.RenJSError.PARAMETER_ERROR);
            }
            if (!((await toChain.isLockAsset(asset)) ||
                ((0, utils_1.isContractChain)(toChain) && (await toChain.isMintAsset(asset))))) {
                throw utils_1.ErrorWithCode.updateError(new Error(`Asset not supported by chain ${toChain.chain}.`), utils_1.RenJSError.PARAMETER_ERROR);
            }
            return await (0, fees_1.estimateTransactionFee)(this.provider, asset, fromChain, toChain);
        };
        /**
         * Return the recommended shard for processing transactions of the specified
         * asset.
         */
        this.selectShard = async (asset) => this.provider.selectShard(asset);
        /**
         * `gateway` initiates a new Gateway for bridging an asset between two
         * chains.
         *
         * See [[Gateway]] for all the options that can be set.
         *
         * @example
         * const gateway = renJS.gateway({
         *     asset: "BTC",
         *     from: bitcoin.GatewayAddress(),
         *     to: ethereum.Account(),
         * });
         * ```
         *
         * @param params See [[GatewayParams]]. This is a serializable object,
         * allowing gateways to be re-created.
         * @param config Optional RenJS config, such as a logger.
         */
        this.gateway = async (params, config = {}) => new gateway_1.Gateway(this.provider, this.getChain(params.from.chain), this.getChain(params.to.chain), Object.assign(Object.assign(Object.assign({}, params), { from: Object.assign({}, params.from), to: Object.assign({}, params.to) }), (params.shard ? { shard: Object.assign({}, params.shard) } : {})), Object.assign(Object.assign({}, this._config), config)).initialize();
        /**
         * `gatewayTransaction` allows you to re-create a transaction emitted
         * by `gateway.on("transaction", (tx) => {...})`.
         *
         * @param params The same type as `tx.params` on an emitted `tx`. This is a
         * serializable object.
         * @param config Optional RenJS config, such as a logger.
         */
        this.gatewayTransaction = async (params, config) => new gatewayTransaction_1.GatewayTransaction(this.provider, this.getChain(params.fromTx.chain), this.getChain(params.to.chain), Object.assign(Object.assign(Object.assign({}, params), { fromTx: Object.assign({}, params.fromTx), to: Object.assign({}, params.to) }), (params.shard ? { shard: Object.assign({}, params.shard) } : {})), undefined, Object.assign(Object.assign({}, this._config), config)).initialize();
        this._config = config || {};
        this.provider =
            typeof providerOrNetwork === "string"
                ? new provider_1.RenVMProvider(providerOrNetwork, this._config.logger)
                : providerOrNetwork;
    }
}
exports.RenJS = RenJS;
/**
 * `Networks` exposes the network options that can be passed in to the RenJS
 * constructor. `Networks.Mainnet` resolves to the string `"mainnet"`.
 */
RenJS.Networks = utils_1.RenNetwork;
/**
 * `RenJS.defaultTransactionHandler` can be passed as a transaction callback when
 * minting. It will handle submitting to RenVM and then to the mint-chain,
 * as long as a valid provider for the mint-chain is given.
 *
 * This is not recommended for front-ends, since it may trigger a wallet
 * pop-up unexpectedly when the mint is ready to be submitted.
 *
 * ```ts
 * gateway.on("transaction", RenJS.defaultTransactionHandler);
 * ```
 */
RenJS.defaultTransactionHandler = defaultTransactionHandler_1.defaultTransactionHandler;
exports.default = RenJS;
//# sourceMappingURL=index.js.map