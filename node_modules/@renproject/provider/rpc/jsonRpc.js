"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonRpcProvider = void 0;
const utils_1 = require("@renproject/utils");
const axios_1 = __importDefault(require("axios"));
const generatePayload = (method, params) => ({
    id: 1,
    jsonrpc: "2.0",
    method,
    params,
});
/**
 * The JsonRpcProvider class implements the Provider interface by connecting to
 * a JSON-RPC endpoint over http/https.
 */
class JsonRpcProvider {
    /**
     * Create a new JsonRpcProvider.
     *
     * @param endpointOrProvider A URI for a RenVM JSON-RPC endpoint, or another
     * JsonRpcProvider to forward calls to.
     * @param logger Optionally pass a logger object.
     */
    constructor(endpointOrProvider, logger = utils_1.defaultLogger) {
        this.sendMessage = async (method, request, retry = 2, timeout = 120 * utils_1.utils.sleep.SECONDS) => {
            const endpoint = this.endpointOrProvider;
            if (typeof endpoint !== "string") {
                return endpoint.sendMessage(method, request, retry, timeout);
            }
            const payload = generatePayload(method, request);
            if (
            // Check level before doing expensive JSON call.
            this.logger.getLevel &&
                this.logger.getLevel() <= utils_1.LogLevel.Debug) {
                this.logger.debug("[request]", JSON.stringify(payload, null, "    "));
            }
            try {
                const response = await utils_1.utils.tryNTimes(async () => axios_1.default.post(endpoint, payload, 
                // Use a 120 second timeout. This could be reduced, but
                // should be done based on the method, since some requests
                // may take a long time, especially on a slow connection.
                { timeout }), retry, 1 * utils_1.utils.sleep.SECONDS);
                if (response.status !== 200) {
                    throw this.responseError(`Unexpected status code ${String(response.status)} returned from node.`, response);
                }
                if (response.data.error) {
                    throw new Error(response.data.error);
                }
                if (response.data.result === undefined) {
                    throw new Error(`Empty result returned from node.`);
                }
                if (this.logger.getLevel &&
                    this.logger.getLevel() <= utils_1.LogLevel.Debug) {
                    this.logger.debug("[response]", JSON.stringify(response.data.result, null, "    "));
                }
                return response.data.result;
            }
            catch (error) {
                // Emit debug log of the endpoint and payload.
                try {
                    this.logger.debug(endpoint, JSON.stringify(payload));
                }
                catch (_errorInner) {
                    // Ignore.
                }
                // Re-throw error to avoid internal axios stack-trace.
                throw new Error(utils_1.utils.extractError(error));
            }
        };
        this.responseError = (msg, response) => {
            const error = new Error(msg);
            error.response = response;
            return error;
        };
        this.logger = logger;
        if (typeof endpointOrProvider === "string" &&
            endpointOrProvider.indexOf("://") === -1) {
            throw new Error(`Invalid node URL without protocol: ${endpointOrProvider}.`);
        }
        this.endpointOrProvider = endpointOrProvider;
    }
}
exports.JsonRpcProvider = JsonRpcProvider;
//# sourceMappingURL=jsonRpc.js.map