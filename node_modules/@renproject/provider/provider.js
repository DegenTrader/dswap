"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RenVMProvider = void 0;
const utils_1 = require("@renproject/utils");
const methods_1 = require("./methods");
const ren_queryBlock_1 = require("./methods/ren_queryBlock");
const jsonRpc_1 = require("./rpc/jsonRpc");
const rpcUrls_1 = require("./rpcUrls");
const unmarshal_1 = require("./unmarshal");
/**
 * The RenVMProvider implements the Provider interface by inheriting from
 * JsonRpcProvider, and extends it with helper methods for calling sendMessage,
 * including marshalling and unmarshalling responses.
 */
class RenVMProvider extends jsonRpc_1.JsonRpcProvider {
    constructor(endpointOrProvider, logger = utils_1.defaultLogger) {
        super(
        // Check if the first parameter is a provider to forward calls to.
        typeof endpointOrProvider !== "string"
            ? endpointOrProvider
            : rpcUrls_1.renRpcUrls[endpointOrProvider] || endpointOrProvider);
        this.getNetwork = async () => {
            const renVMConfig = await this.queryConfig();
            return renVMConfig.network;
        };
        this.queryBlock = async (blockHeight, retry) => utils_1.pack.unmarshal.unmarshalPackStruct(ren_queryBlock_1.renVMBlockType, (await this.sendMessage(methods_1.RPCMethod.QueryBlock, {
            blockHeight: utils_1.utils.isDefined(blockHeight)
                ? blockHeight.toString()
                : undefined,
        }, retry)).block);
        this.queryBlocks = async (blockHeight, n, retry) => utils_1.pack.unmarshal.unmarshalPackList({ list: ren_queryBlock_1.renVMBlockType }, (await this.sendMessage(methods_1.RPCMethod.QueryBlocks, {
            blockHeight: utils_1.utils.isDefined(blockHeight)
                ? blockHeight.toString()
                : undefined,
            n: utils_1.utils.isDefined(n) ? n.toString() : undefined,
        }, retry)).blocks);
        this.submitTx = async (tx, retry) => {
            await this.sendMessage(methods_1.RPCMethod.SubmitTx, { tx }, retry);
        };
        this.queryTxs = async ({ txStatus, offset, limit, latest, }, 
        // Retry specifies how many attempts should be made to fetch the
        // result of the queryTxs.
        retry) => (await this.sendMessage(methods_1.RPCMethod.QueryTxs, Object.assign(Object.assign(Object.assign(Object.assign({}, (utils_1.utils.isDefined(txStatus)
            ? { txStatus: txStatus }
            : {})), (utils_1.utils.isDefined(limit)
            ? { limit: limit.toString() }
            : {})), (utils_1.utils.isDefined(offset)
            ? { offset: offset.toString() }
            : {})), (utils_1.utils.isDefined(latest) ? { latest: latest } : {})), retry)).txs.map((tx) => (0, unmarshal_1.unmarshalRenVMTransaction)(tx));
        this.queryConfig = utils_1.utils.memoize(async (retry) => await this.sendMessage(methods_1.RPCMethod.QueryConfig, {}, retry));
        this.queryBlockState = utils_1.utils.memoize(async (contract, retry) => {
            const { state } = await this.sendMessage(methods_1.RPCMethod.QueryBlockState, { contract }, retry);
            return utils_1.pack.unmarshal.unmarshalTypedPackValue(state);
        });
        this.submitGateway = async (gateway, params, retries) => {
            const { selector, gHash, gPubKey, nHash, nonce, payload, pHash, to } = params;
            (0, utils_1.assertType)("Uint8Array", {
                gHash,
                gPubKey,
                nHash,
                nonce,
                payload,
                pHash,
            });
            (0, utils_1.assertType)("string", { to });
            const txIn = {
                t: methods_1.submitGatewayType,
                v: {
                    ghash: utils_1.utils.toURLBase64(gHash),
                    gpubkey: utils_1.utils.toURLBase64(gPubKey),
                    nhash: utils_1.utils.toURLBase64(nHash),
                    nonce: utils_1.utils.toURLBase64(nonce),
                    payload: utils_1.utils.toURLBase64(payload),
                    phash: utils_1.utils.toURLBase64(pHash),
                    to,
                },
            };
            const tx = {
                selector: selector,
                version: "1",
                // TODO: Fix types
                in: txIn,
            };
            await this.sendMessage(methods_1.RPCMethod.SubmitGateway, { gateway, tx }, retries);
            return gateway;
        };
        /**
         * Queries the result of a RenVM transaction and unmarshals the result into
         * a [[LockAndMintTransaction]] or [[BurnAndReleaseTransaction]].
         *
         * @param txHash The transaction hash in URL-base64.
         */
        this.queryTx = async (txHash, retries) => {
            (0, utils_1.assertType)("string", { txHash });
            let response;
            try {
                response = await this.sendMessage(methods_1.RPCMethod.QueryTx, { txHash }, retries);
            }
            catch (error) {
                const message = error.message || "";
                if (message.match(/^invalid params: /)) {
                    throw utils_1.ErrorWithCode.updateError(error, utils_1.RenJSError.PARAMETER_ERROR);
                }
                else if (message.match(/not found$/)) {
                    throw utils_1.ErrorWithCode.updateError(error, utils_1.RenJSError.TRANSACTION_NOT_FOUND);
                }
                else {
                    throw utils_1.ErrorWithCode.updateError(error, utils_1.RenJSError.UNKNOWN_ERROR);
                }
            }
            try {
                return {
                    tx: (0, unmarshal_1.unmarshalRenVMTransaction)(response.tx),
                    txStatus: response.txStatus,
                };
            }
            catch (error) {
                throw utils_1.ErrorWithCode.updateError(error, error.code || utils_1.RenJSError.INTERNAL_ERROR);
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        };
        /**
         * selectShard fetches the public key for the RenVM shard handling
         * the provided contract.
         */
        this.selectShard = async (asset) => {
            let blockState;
            try {
                // Call the ren_queryBlockState RPC.
                blockState = await this.queryBlockState(asset, 5);
            }
            catch (error) {
                throw utils_1.ErrorWithCode.updateError(error, utils_1.RenJSError.NETWORK_ERROR, `Error fetching RenVM shards`);
            }
            if (!blockState[asset]) {
                throw new Error(`No RenVM block state found for ${asset}.`);
            }
            const pubKey = blockState[asset].shards[0].pubKey;
            if (!pubKey || pubKey.length === 0) {
                throw new Error(`Unable to fetch RenVM public key for ${asset}.`);
            }
            (0, utils_1.assertType)("Uint8Array", { pubKey });
            return {
                gPubKey: utils_1.utils.toURLBase64(pubKey),
            };
        };
        this.getConfirmationTarget = async (chainName) => {
            const renVMConfig = await this.queryConfig();
            return parseInt(renVMConfig.confirmations[chainName], 10);
        };
        this.selectorWhitelisted = async (selector) => {
            const renVMConfig = await this.queryConfig();
            return renVMConfig.whitelist.includes(selector);
        };
        this.logger = logger;
    }
}
exports.RenVMProvider = RenVMProvider;
//# sourceMappingURL=provider.js.map