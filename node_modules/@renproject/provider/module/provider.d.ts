import { Logger, RenNetwork, RenNetworkString, RenVMShard, TxStatus } from "@renproject/utils";
import { ParamsSubmitTx, RPCParams, RPCResponses } from "./methods";
import { BlockState } from "./methods/ren_queryBlockState";
import { JsonRpcProvider, Provider } from "./rpc/jsonRpc";
import { RenVMBlock, RenVMCrossChainTransaction, RenVMTransaction, RenVMTransactionWithStatus } from "./types/core";
export interface RenVMProviderInterface extends Provider<RPCParams, RPCResponses> {
    getNetwork: () => Promise<string>;
    queryBlock: (blockHeight: number, retry?: number) => Promise<RenVMBlock>;
    queryBlocks: (blockHeight: number, n: number, retry?: number) => Promise<RenVMBlock[]>;
    submitTx: (tx: ParamsSubmitTx["tx"], retry?: number) => Promise<void>;
    /**
     * Queries the result of a RenVM transaction and unmarshals the result into
     * a [[RenVMCrossChainTransaction]].
     *
     * @param txHash The transaction hash in URL-base64.
     */
    queryTx: <T extends RenVMTransactionWithStatus = RenVMTransactionWithStatus<RenVMCrossChainTransaction>>(txHash: string, retries?: number) => Promise<T>;
    queryTxs: ({ txStatus, offset, limit, latest, }: {
        txStatus?: TxStatus;
        offset?: number;
        limit?: number;
        latest?: boolean;
    }, retries?: number) => Promise<RenVMTransaction[]>;
    queryBlockState: (contract: string, retry?: number) => Promise<BlockState>;
    submitGateway: (gateway: string, params: {
        selector: string;
        gHash: Uint8Array;
        gPubKey: Uint8Array;
        nHash: Uint8Array;
        nonce: Uint8Array;
        payload: Uint8Array;
        pHash: Uint8Array;
        to: string;
    }, retries?: number) => Promise<string>;
    /**
     * selectShard fetches the key for the RenVM shard handling
     * the provided contract.
     */
    selectShard: (asset: string) => Promise<RenVMShard>;
    getConfirmationTarget: (chainName: string) => Promise<number>;
}
/**
 * The RenVMProvider implements the Provider interface by inheriting from
 * JsonRpcProvider, and extends it with helper methods for calling sendMessage,
 * including marshalling and unmarshalling responses.
 */
export declare class RenVMProvider extends JsonRpcProvider<RPCParams, RPCResponses> {
    logger: Logger;
    constructor(endpointOrProvider: RenNetwork | RenNetworkString | string | Provider<RPCParams, RPCResponses>, logger?: Logger);
    getNetwork: () => Promise<string>;
    queryBlock: (blockHeight?: number, retry?: number) => Promise<RenVMBlock>;
    queryBlocks: (blockHeight?: number, n?: number, retry?: number) => Promise<RenVMBlock[]>;
    submitTx: (tx: ParamsSubmitTx["tx"], retry?: number) => Promise<void>;
    queryTxs: ({ txStatus, offset, limit, latest, }: {
        txStatus?: TxStatus | undefined;
        offset?: number | undefined;
        limit?: number | undefined;
        latest?: boolean | undefined;
    }, retry?: number) => Promise<RenVMTransaction[]>;
    queryConfig: (retry?: number | undefined) => Promise<import("./methods").ResponseQueryConfig>;
    queryBlockState: (contract: string, retry?: number | undefined) => Promise<BlockState>;
    submitGateway: (gateway: string, params: {
        selector: string;
        gHash: Uint8Array;
        gPubKey: Uint8Array;
        nHash: Uint8Array;
        nonce: Uint8Array;
        payload: Uint8Array;
        pHash: Uint8Array;
        to: string;
    }, retries?: number) => Promise<string>;
    /**
     * Queries the result of a RenVM transaction and unmarshals the result into
     * a [[LockAndMintTransaction]] or [[BurnAndReleaseTransaction]].
     *
     * @param txHash The transaction hash in URL-base64.
     */
    readonly queryTx: <T extends RenVMTransactionWithStatus<RenVMTransaction<any, any>> = RenVMTransactionWithStatus<RenVMCrossChainTransaction>>(txHash: string, retries?: number) => Promise<T>;
    /**
     * selectShard fetches the public key for the RenVM shard handling
     * the provided contract.
     */
    readonly selectShard: (asset: string) => Promise<RenVMShard>;
    getConfirmationTarget: (chainName: string) => Promise<number>;
    selectorWhitelisted: (selector: string) => Promise<boolean>;
}
//# sourceMappingURL=provider.d.ts.map