var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { assertType, defaultLogger, ErrorWithCode, pack, RenJSError, utils, } from "@renproject/utils";
import { RPCMethod, submitGatewayType, } from "./methods";
import { renVMBlockType } from "./methods/ren_queryBlock";
import { JsonRpcProvider } from "./rpc/jsonRpc";
import { renRpcUrls } from "./rpcUrls";
import { unmarshalRenVMTransaction } from "./unmarshal";
/**
 * The RenVMProvider implements the Provider interface by inheriting from
 * JsonRpcProvider, and extends it with helper methods for calling sendMessage,
 * including marshalling and unmarshalling responses.
 */
export class RenVMProvider extends JsonRpcProvider {
    constructor(endpointOrProvider, logger = defaultLogger) {
        super(
        // Check if the first parameter is a provider to forward calls to.
        typeof endpointOrProvider !== "string"
            ? endpointOrProvider
            : renRpcUrls[endpointOrProvider] || endpointOrProvider);
        this.getNetwork = () => __awaiter(this, void 0, void 0, function* () {
            const renVMConfig = yield this.queryConfig();
            return renVMConfig.network;
        });
        this.queryBlock = (blockHeight, retry) => __awaiter(this, void 0, void 0, function* () {
            return pack.unmarshal.unmarshalPackStruct(renVMBlockType, (yield this.sendMessage(RPCMethod.QueryBlock, {
                blockHeight: utils.isDefined(blockHeight)
                    ? blockHeight.toString()
                    : undefined,
            }, retry)).block);
        });
        this.queryBlocks = (blockHeight, n, retry) => __awaiter(this, void 0, void 0, function* () {
            return pack.unmarshal.unmarshalPackList({ list: renVMBlockType }, (yield this.sendMessage(RPCMethod.QueryBlocks, {
                blockHeight: utils.isDefined(blockHeight)
                    ? blockHeight.toString()
                    : undefined,
                n: utils.isDefined(n) ? n.toString() : undefined,
            }, retry)).blocks);
        });
        this.submitTx = (tx, retry) => __awaiter(this, void 0, void 0, function* () {
            yield this.sendMessage(RPCMethod.SubmitTx, { tx }, retry);
        });
        this.queryTxs = ({ txStatus, offset, limit, latest, }, 
        // Retry specifies how many attempts should be made to fetch the
        // result of the queryTxs.
        retry) => __awaiter(this, void 0, void 0, function* () {
            return (yield this.sendMessage(RPCMethod.QueryTxs, Object.assign(Object.assign(Object.assign(Object.assign({}, (utils.isDefined(txStatus)
                ? { txStatus: txStatus }
                : {})), (utils.isDefined(limit)
                ? { limit: limit.toString() }
                : {})), (utils.isDefined(offset)
                ? { offset: offset.toString() }
                : {})), (utils.isDefined(latest) ? { latest: latest } : {})), retry)).txs.map((tx) => unmarshalRenVMTransaction(tx));
        });
        this.queryConfig = utils.memoize((retry) => __awaiter(this, void 0, void 0, function* () {
            return yield this.sendMessage(RPCMethod.QueryConfig, {}, retry);
        }));
        this.queryBlockState = utils.memoize((contract, retry) => __awaiter(this, void 0, void 0, function* () {
            const { state } = yield this.sendMessage(RPCMethod.QueryBlockState, { contract }, retry);
            return pack.unmarshal.unmarshalTypedPackValue(state);
        }));
        this.submitGateway = (gateway, params, retries) => __awaiter(this, void 0, void 0, function* () {
            const { selector, gHash, gPubKey, nHash, nonce, payload, pHash, to } = params;
            assertType("Uint8Array", {
                gHash,
                gPubKey,
                nHash,
                nonce,
                payload,
                pHash,
            });
            assertType("string", { to });
            const txIn = {
                t: submitGatewayType,
                v: {
                    ghash: utils.toURLBase64(gHash),
                    gpubkey: utils.toURLBase64(gPubKey),
                    nhash: utils.toURLBase64(nHash),
                    nonce: utils.toURLBase64(nonce),
                    payload: utils.toURLBase64(payload),
                    phash: utils.toURLBase64(pHash),
                    to,
                },
            };
            const tx = {
                selector: selector,
                version: "1",
                // TODO: Fix types
                in: txIn,
            };
            yield this.sendMessage(RPCMethod.SubmitGateway, { gateway, tx }, retries);
            return gateway;
        });
        /**
         * Queries the result of a RenVM transaction and unmarshals the result into
         * a [[LockAndMintTransaction]] or [[BurnAndReleaseTransaction]].
         *
         * @param txHash The transaction hash in URL-base64.
         */
        this.queryTx = (txHash, retries) => __awaiter(this, void 0, void 0, function* () {
            assertType("string", { txHash });
            let response;
            try {
                response = yield this.sendMessage(RPCMethod.QueryTx, { txHash }, retries);
            }
            catch (error) {
                const message = error.message || "";
                if (message.match(/^invalid params: /)) {
                    throw ErrorWithCode.updateError(error, RenJSError.PARAMETER_ERROR);
                }
                else if (message.match(/not found$/)) {
                    throw ErrorWithCode.updateError(error, RenJSError.TRANSACTION_NOT_FOUND);
                }
                else {
                    throw ErrorWithCode.updateError(error, RenJSError.UNKNOWN_ERROR);
                }
            }
            try {
                return {
                    tx: unmarshalRenVMTransaction(response.tx),
                    txStatus: response.txStatus,
                };
            }
            catch (error) {
                throw ErrorWithCode.updateError(error, error.code || RenJSError.INTERNAL_ERROR);
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        });
        /**
         * selectShard fetches the public key for the RenVM shard handling
         * the provided contract.
         */
        this.selectShard = (asset) => __awaiter(this, void 0, void 0, function* () {
            let blockState;
            try {
                // Call the ren_queryBlockState RPC.
                blockState = yield this.queryBlockState(asset, 5);
            }
            catch (error) {
                throw ErrorWithCode.updateError(error, RenJSError.NETWORK_ERROR, `Error fetching RenVM shards`);
            }
            if (!blockState[asset]) {
                throw new Error(`No RenVM block state found for ${asset}.`);
            }
            const pubKey = blockState[asset].shards[0].pubKey;
            if (!pubKey || pubKey.length === 0) {
                throw new Error(`Unable to fetch RenVM public key for ${asset}.`);
            }
            assertType("Uint8Array", { pubKey });
            return {
                gPubKey: utils.toURLBase64(pubKey),
            };
        });
        this.getConfirmationTarget = (chainName) => __awaiter(this, void 0, void 0, function* () {
            const renVMConfig = yield this.queryConfig();
            return parseInt(renVMConfig.confirmations[chainName], 10);
        });
        this.selectorWhitelisted = (selector) => __awaiter(this, void 0, void 0, function* () {
            const renVMConfig = yield this.queryConfig();
            return renVMConfig.whitelist.includes(selector);
        });
        this.logger = logger;
    }
}
//# sourceMappingURL=provider.js.map