var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { defaultLogger, LogLevel, utils, } from "@renproject/utils";
import axios from "axios";
const generatePayload = (method, params) => ({
    id: 1,
    jsonrpc: "2.0",
    method,
    params,
});
/**
 * The JsonRpcProvider class implements the Provider interface by connecting to
 * a JSON-RPC endpoint over http/https.
 */
export class JsonRpcProvider {
    /**
     * Create a new JsonRpcProvider.
     *
     * @param endpointOrProvider A URI for a RenVM JSON-RPC endpoint, or another
     * JsonRpcProvider to forward calls to.
     * @param logger Optionally pass a logger object.
     */
    constructor(endpointOrProvider, logger = defaultLogger) {
        this.sendMessage = (method, request, retry = 2, timeout = 120 * utils.sleep.SECONDS) => __awaiter(this, void 0, void 0, function* () {
            const endpoint = this.endpointOrProvider;
            if (typeof endpoint !== "string") {
                return endpoint.sendMessage(method, request, retry, timeout);
            }
            const payload = generatePayload(method, request);
            if (
            // Check level before doing expensive JSON call.
            this.logger.getLevel &&
                this.logger.getLevel() <= LogLevel.Debug) {
                this.logger.debug("[request]", JSON.stringify(payload, null, "    "));
            }
            try {
                const response = yield utils.tryNTimes(() => __awaiter(this, void 0, void 0, function* () {
                    return axios.post(endpoint, payload, 
                    // Use a 120 second timeout. This could be reduced, but
                    // should be done based on the method, since some requests
                    // may take a long time, especially on a slow connection.
                    { timeout });
                }), retry, 1 * utils.sleep.SECONDS);
                if (response.status !== 200) {
                    throw this.responseError(`Unexpected status code ${String(response.status)} returned from node.`, response);
                }
                if (response.data.error) {
                    throw new Error(response.data.error);
                }
                if (response.data.result === undefined) {
                    throw new Error(`Empty result returned from node.`);
                }
                if (this.logger.getLevel &&
                    this.logger.getLevel() <= LogLevel.Debug) {
                    this.logger.debug("[response]", JSON.stringify(response.data.result, null, "    "));
                }
                return response.data.result;
            }
            catch (error) {
                // Emit debug log of the endpoint and payload.
                try {
                    this.logger.debug(endpoint, JSON.stringify(payload));
                }
                catch (_errorInner) {
                    // Ignore.
                }
                // Re-throw error to avoid internal axios stack-trace.
                throw new Error(utils.extractError(error));
            }
        });
        this.responseError = (msg, response) => {
            const error = new Error(msg);
            error.response = response;
            return error;
        };
        this.logger = logger;
        if (typeof endpointOrProvider === "string" &&
            endpointOrProvider.indexOf("://") === -1) {
            throw new Error(`Invalid node URL without protocol: ${endpointOrProvider}.`);
        }
        this.endpointOrProvider = endpointOrProvider;
    }
}
//# sourceMappingURL=jsonRpc.js.map