import { ChainTransaction, DepositChain, InputChainTransaction, InputType, OutputType } from "@renproject/utils";
import BigNumber from "bignumber.js";
import { APIWithPriority, BitcoinAPI, CombinedAPI } from "./APIs/API";
import { BitcoinInputPayload, BitcoinNetworkConfig, BitcoinNetworkConfigMap, BitcoinNetworkInput, BitcoinOutputPayload } from "./utils/types";
/**
 * A base Bitcoin chain class that is extended by each Bitcoin chain/fork.
 */
export declare abstract class BitcoinBaseChain implements DepositChain<BitcoinInputPayload, BitcoinOutputPayload> {
    static chain: string;
    chain: string;
    assets: {
        [asset: string]: string;
    };
    static configMap: BitcoinNetworkConfigMap;
    configMap: BitcoinNetworkConfigMap;
    network: BitcoinNetworkConfig;
    api: CombinedAPI;
    constructor({ network }: {
        network: BitcoinNetworkInput;
    });
    withAPI: (api: BitcoinAPI | APIWithPriority, { priority }?: {
        priority?: number | undefined;
    }) => this;
    getOutputPayload: (asset: string, _inputType: InputType, _outputType: OutputType, toPayload: BitcoinOutputPayload) => {
        to: string;
        toBytes: Uint8Array;
        payload: Uint8Array;
    } | undefined;
    addressExplorerLink: (address: string) => string | undefined;
    transactionExplorerLink: ({ txid, txHash, }: Partial<ChainTransaction> & ({
        txid: string;
    } | {
        txHash: string;
    })) => string | undefined;
    getBalance: (asset: string, address: string) => Promise<BigNumber>;
    validateAddress: (address: string) => boolean;
    addressToBytes: (address: string) => Uint8Array;
    addressFromBytes: (bytes: Uint8Array) => string;
    txHashToBytes: (txHash: string) => Uint8Array;
    txHashFromBytes: (bytes: Uint8Array) => string;
    validateTransaction: (transaction: Partial<ChainTransaction> & ({
        txid: string;
    } | {
        txHash: string;
    })) => boolean;
    /**
     * See [[LockChain.isLockAsset]].
     */
    isLockAsset: (asset: string) => boolean;
    isDepositAsset: (asset: string) => boolean;
    private _assertAssetIsSupported;
    /**
     * See [[LockChain.assetDecimals]].
     */
    assetDecimals: (asset: string) => number;
    watchForDeposits: (asset: string, fromPayload: BitcoinInputPayload, address: string, onInput: (input: InputChainTransaction) => void, _removeInput: (input: InputChainTransaction) => void, listenerCancelled: () => boolean) => Promise<void>;
    /**
     * See [[LockChain.transactionConfidence]].
     */
    transactionConfidence: (transaction: ChainTransaction) => Promise<BigNumber>;
    /**
     * See [[LockChain.getGatewayAddress]].
     */
    createGatewayAddress: (asset: string, fromPayload: BitcoinInputPayload, shardPublicKey: Uint8Array, gHash: Uint8Array) => Promise<string> | string;
    /**
     * When burning, you can call `Bitcoin.Address("...")` to make the address
     * available to the burn params.
     *
     * @category Main
     */
    Address: (address: string) => BitcoinOutputPayload;
    /**
     * When burning, you can call `Bitcoin.Address("...")` to make the address
     * available to the burn params.
     *
     * @category Main
     */
    GatewayAddress: () => BitcoinInputPayload;
    /**
     * Import an existing Bitcoin transaction instead of watching for deposits
     * to a gateway address.
     *
     * @example
     * bitcoin.Transaction({
     *   txHash: "a1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d",
     *   txindex: "0"
     * })
     */
    Transaction: (partialTx: Partial<ChainTransaction> & {
        txindex: string;
    } & ({
        txid: string;
    } | {
        txHash: string;
    })) => BitcoinInputPayload;
    toSats: (value: BigNumber | string | number) => string;
    fromSats: (value: BigNumber | string | number) => string;
}
//# sourceMappingURL=base.d.ts.map