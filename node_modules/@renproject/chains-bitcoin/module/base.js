var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { assertType, ErrorWithCode, populateChainTransaction, RenJSError, utils, } from "@renproject/utils";
import BigNumber from "bignumber.js";
import base58 from "bs58";
import { validate } from "wallet-address-validator";
import { CombinedAPI } from "./APIs/API";
import { createAddressArray } from "./script/index";
import { isBitcoinNetworkConfig, } from "./utils/types";
import { addressToBytes, hash160, txHashFromBytes, txHashToBytes, } from "./utils/utils";
/**
 * A base Bitcoin chain class that is extended by each Bitcoin chain/fork.
 */
export class BitcoinBaseChain {
    constructor({ network }) {
        this.assets = {};
        this.configMap = {};
        this.api = new CombinedAPI();
        this.withAPI = (api, { priority = 0 } = {}) => {
            this.api.withAPI(api, { priority });
            return this;
        };
        this.getOutputPayload = (asset, _inputType, _outputType, toPayload) => {
            this._assertAssetIsSupported(asset);
            const address = toPayload.params.address;
            if (!address) {
                // throw new Error(`No ${this.chain} address specified.`);
                return undefined;
            }
            return {
                to: address,
                toBytes: this.addressToBytes(address),
                payload: new Uint8Array(),
            };
        };
        this.addressExplorerLink = (address) => {
            return this.network.explorer.address(address);
        };
        this.transactionExplorerLink = ({ txid, txHash, }) => {
            if (txHash) {
                return this.network.explorer.transaction(txHash);
            }
            else if (txid) {
                return this.network.explorer.transaction(this.txHashFromBytes(utils.fromBase64(txid)));
            }
            return undefined;
        };
        this.getBalance = (asset, address) => __awaiter(this, void 0, void 0, function* () {
            this._assertAssetIsSupported(asset);
            if (!this.validateAddress(address)) {
                throw new Error(`Invalid address ${address}.`);
            }
            // TODO: Implement.
            return new BigNumber(0);
        });
        this.validateAddress = (address) => {
            try {
                return validate(address, this.network.nativeAsset.symbol, this.network.isTestnet ? "testnet" : "prod");
            }
            catch (error) {
                return false;
            }
        };
        this.addressToBytes = (address) => {
            return addressToBytes(address);
        };
        this.addressFromBytes = (bytes) => {
            return base58.encode(bytes);
        };
        this.txHashToBytes = (txHash) => {
            return txHashToBytes(txHash);
        };
        this.txHashFromBytes = (bytes) => {
            return txHashFromBytes(bytes);
        };
        this.validateTransaction = (transaction) => {
            return ((utils.isDefined(transaction.txid) ||
                utils.isDefined(transaction.txHash)) &&
                (transaction.txHash
                    ? utils.isHex(transaction.txHash, {
                        length: 32,
                    })
                    : true) &&
                (transaction.txid
                    ? utils.isURLBase64(transaction.txid, {
                        length: 32,
                    })
                    : true) &&
                (transaction.txindex
                    ? !new BigNumber(transaction.txindex).isNaN()
                    : true) &&
                (transaction.txHash && transaction.txid
                    ? utils.toURLBase64(txHashToBytes(transaction.txHash)) ===
                        transaction.txid
                    : true));
        };
        /**
         * See [[LockChain.isLockAsset]].
         */
        this.isLockAsset = (asset) => {
            return asset === this.network.nativeAsset.symbol;
        };
        this.isDepositAsset = (asset) => {
            this._assertAssetIsSupported(asset);
            return true;
        };
        this._assertAssetIsSupported = (asset) => {
            if (!this.isLockAsset(asset)) {
                throw new Error(`Asset ${asset} not supported on ${this.chain}.`);
            }
        };
        /**
         * See [[LockChain.assetDecimals]].
         */
        this.assetDecimals = (asset) => {
            this._assertAssetIsSupported(asset);
            return 8;
        };
        this.watchForDeposits = (asset, fromPayload, address, onInput, _removeInput, listenerCancelled) => __awaiter(this, void 0, void 0, function* () {
            this._assertAssetIsSupported(asset);
            if (fromPayload.chain !== this.chain) {
                throw new Error(`Invalid payload for chain ${fromPayload.chain} instead of ${this.chain}.`);
            }
            // If the payload is a transaction, submit it to onInput and then loop
            // indefinitely.
            if (fromPayload.type === "transaction") {
                const inputTx = fromPayload.params.tx;
                if (inputTx.amount === undefined) {
                    while (true) {
                        try {
                            const tx = yield this.api.fetchUTXO(inputTx.txHash, inputTx.txindex);
                            onInput({
                                chain: this.chain,
                                txid: utils.toURLBase64(utils.fromHex(tx.txid).reverse()),
                                txHash: tx.txid,
                                txindex: tx.txindex,
                                explorerLink: this.transactionExplorerLink({
                                    txHash: tx.txid,
                                }) || "",
                                asset,
                                amount: tx.amount,
                            });
                            break;
                        }
                        catch (error) {
                            console.error(error);
                        }
                    }
                    while (true) {
                        yield utils.sleep(15 * utils.sleep.SECONDS);
                    }
                }
            }
            try {
                const txs = yield utils.tryNTimes(() => __awaiter(this, void 0, void 0, function* () { return this.api.fetchTXs(address); }), 2);
                txs.map((tx) => onInput({
                    chain: this.chain,
                    txid: utils.toURLBase64(utils.fromHex(tx.txid).reverse()),
                    txHash: tx.txid,
                    txindex: tx.txindex,
                    explorerLink: this.transactionExplorerLink({
                        txHash: tx.txid,
                    }) || "",
                    asset,
                    amount: tx.amount,
                }));
            }
            catch (error) {
                // Ignore error and fallback to getUTXOs.
            }
            while (true) {
                if (listenerCancelled()) {
                    return;
                }
                try {
                    const utxos = yield this.api.fetchUTXOs(address);
                    utxos.map((tx) => onInput({
                        chain: this.chain,
                        txid: utils.toURLBase64(utils.fromHex(tx.txid).reverse()),
                        txHash: tx.txid,
                        txindex: tx.txindex,
                        explorerLink: this.transactionExplorerLink({
                            txHash: tx.txid,
                        }) || "",
                        asset,
                        amount: tx.amount,
                    }));
                }
                catch (error) {
                    console.error(error);
                }
                yield utils.sleep(15 * utils.sleep.SECONDS);
            }
        });
        /**
         * See [[LockChain.transactionConfidence]].
         */
        this.transactionConfidence = (transaction) => __awaiter(this, void 0, void 0, function* () {
            const { height } = yield this.api.fetchUTXO(transaction.txHash, transaction.txindex);
            if (!height) {
                return new BigNumber(0);
            }
            else {
                const latestHeight = new BigNumber(yield this.api.fetchHeight());
                return latestHeight.minus(height).plus(1);
            }
        });
        /**
         * See [[LockChain.getGatewayAddress]].
         */
        this.createGatewayAddress = (asset, fromPayload, shardPublicKey, gHash) => {
            this._assertAssetIsSupported(asset);
            if (fromPayload.chain !== this.chain) {
                throw new Error(`Invalid payload for chain ${fromPayload.chain} instead of ${this.chain}.`);
            }
            return this.addressFromBytes(createAddressArray(hash160(shardPublicKey), gHash, this.network.p2shPrefix));
        };
        // Methods for initializing mints and burns ////////////////////////////////
        /**
         * When burning, you can call `Bitcoin.Address("...")` to make the address
         * available to the burn params.
         *
         * @category Main
         */
        this.Address = (address) => {
            // Type validation
            assertType("string", { address });
            if (!this.validateAddress(address)) {
                throw ErrorWithCode.updateError(new Error(`Invalid ${this.chain} address: ${String(address)}`), RenJSError.PARAMETER_ERROR);
            }
            return {
                chain: this.chain,
                type: "address",
                params: {
                    address,
                },
            };
        };
        /**
         * When burning, you can call `Bitcoin.Address("...")` to make the address
         * available to the burn params.
         *
         * @category Main
         */
        this.GatewayAddress = () => {
            return {
                chain: this.chain,
                type: "gatewayAddress",
            };
        };
        /**
         * Import an existing Bitcoin transaction instead of watching for deposits
         * to a gateway address.
         *
         * @example
         * bitcoin.Transaction({
         *   txHash: "a1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d",
         *   txindex: "0"
         * })
         */
        this.Transaction = (partialTx) => {
            return {
                chain: this.chain,
                type: "transaction",
                params: {
                    tx: populateChainTransaction({
                        partialTx,
                        chain: this.chain,
                        txHashToBytes,
                        txHashFromBytes,
                        explorerLink: this.transactionExplorerLink,
                    }),
                },
            };
        };
        this.toSats = (value) => {
            return new BigNumber(value).shiftedBy(8).decimalPlaces(0).toFixed();
        };
        this.fromSats = (value) => {
            return new BigNumber(value).shiftedBy(-8).toFixed();
        };
        const networkConfig = isBitcoinNetworkConfig(network)
            ? network
            : this.configMap[network];
        if (!networkConfig) {
            if (typeof network === "string") {
                throw new Error(`Unknown network ${network}.`);
            }
            else {
                throw new Error(`Invalid network config.`);
            }
        }
        this.network = networkConfig;
        this.chain = this.network.selector;
        for (const provider of this.network.providers) {
            this.withAPI(provider);
        }
    }
}
BitcoinBaseChain.configMap = {};
//# sourceMappingURL=base.js.map