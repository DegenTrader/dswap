import { ripemd160 as createRipemd160 } from "@noble/hashes/ripemd160";
import { assertType, utils } from "@renproject/utils";
import { bech32 } from "bech32";
import base58 from "bs58";
import { isBitcoinNetworkConfig, } from "./types";
export const addressToBytes = (address) => {
    // Attempt to decode address as a bech32 address, and if that fails
    // fall back to base58.
    try {
        const [type, ...words] = bech32.decode(address).words;
        return utils.concat([
            new Uint8Array([type]),
            new Uint8Array(bech32.fromWords(words)),
        ]);
    }
    catch (error) {
        try {
            return new Uint8Array(base58.decode(address));
        }
        catch (internalError) {
            throw new Error(`Unrecognized address format "${address}".`);
        }
    }
};
export const StandardBitcoinExplorer = (baseUrl) => ({
    url: baseUrl,
    address: (address) => `${baseUrl.replace(/\/$/, "")}/address/${address}`,
    transaction: (transaction) => `${baseUrl.replace(/\/$/, "")}/tx/${transaction || ""}`,
});
export const SoChainExplorer = (chainPath, chainId) => ({
    url: `https://sochain.com/${chainPath}`,
    address: (address) => `https://sochain.com/address/${chainId}/${address}`,
    transaction: (transaction) => `https://sochain.com/tx/${chainId}/${transaction}`,
});
export const resolveBitcoinNetworkConfig = (configMap, renNetwork) => {
    let networkConfig;
    if (renNetwork && isBitcoinNetworkConfig(renNetwork)) {
        networkConfig = renNetwork;
    }
    else {
        networkConfig = configMap[renNetwork];
    }
    if (!networkConfig) {
        throw new Error(`Unsupported network '${String(renNetwork
            ? typeof renNetwork === "string"
                ? renNetwork
                : renNetwork.selector
            : renNetwork)}'. Valid options are 'mainnet', 'testnet' or a BitcoinNetworkConfig object.`);
    }
    return networkConfig;
};
/** Calculate the ripemd160 hash of the input. */
export const ripemd160 = (...msg) => {
    assertType("Uint8Array[]", { msg });
    return new Uint8Array(createRipemd160(utils.concat(msg)));
};
/**
 * hash160 is used to calculate the Bitcoin address from a private key, and is
 * equivalent to `ripemd160(sha256(publicKey))`
 */
export const hash160 = (...msg) => {
    assertType("Uint8Array[]", { msg });
    return ripemd160(utils.sha256(utils.concat(msg)));
};
/**
 * Convert a Bitcoin transaction hash from its standard format to the format
 * required by RenVM.
 *
 * @param txHash A Bitcoin transaction hash formatted as an unprefixed
 * hex string.
 * @returns The bytes representing the same txHash.
 */
export const txHashToBytes = (txHash) => {
    return utils.fromHex(txHash).reverse();
};
/**
 * Convert a Bitcoin transaction hash from the format required by RenVM to its
 * standard format.
 *
 * @param bytes Bytes representing a Bitcoin hash.
 * @returns The same Bitcoin transaction hash formatted as an unprefixed hex
 * string.
 */
export const txHashFromBytes = (bytes) => {
    // Create new Uint8Array before reversing to avoid modifying the input
    // array.
    return utils.toHex(new Uint8Array(bytes).reverse());
};
//# sourceMappingURL=utils.js.map