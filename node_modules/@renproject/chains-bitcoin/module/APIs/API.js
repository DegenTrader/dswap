var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { utils } from "@renproject/utils";
import BigNumber from "bignumber.js";
// Default timeout for network requests.
const SECONDS = 1000;
export const DEFAULT_TIMEOUT = 30 * SECONDS;
/**
 * sortUTXOs compares two UTXOs by height, then amount, then txid, then txindex.
 *
 * @returns a negative value to represent that a should come before b or a
 * positive value to represent that b should come before a, or 0 if a and b are
 * equal.
 */
export const sortUTXOs = (a, b) => {
    const aHeight = a.height ? new BigNumber(a.height) : null;
    const bHeight = b.height ? new BigNumber(b.height) : null;
    // Compare heights first
    if (aHeight) {
        if (bHeight) {
            if (!aHeight.isEqualTo(bHeight))
                return bHeight.minus(aHeight).toNumber();
        }
        else {
            return -1;
        }
    }
    else if (bHeight) {
        return 1;
    }
    // If the heights are the same (same number of both null), compare amounts.
    const aAmount = new BigNumber(a.amount);
    const bAmount = new BigNumber(b.amount);
    if (aAmount.isEqualTo(bAmount)) {
        return bAmount.minus(aAmount).toNumber();
    }
    // If the heights and amounts are equal, compare txid.
    if (a.txid !== b.txid) {
        return a.txid <= b.txid ? -1 : 1;
    }
    // Fall back to the txindex. If the txid and txindex are the same for both
    // transactions, then the two transactions represent the same transfer, and
    // the returned value is `0`.
    const aTxindex = new BigNumber(a.txindex);
    const bTxindex = new BigNumber(b.txindex);
    return bTxindex.minus(aTxindex).toNumber();
};
/**
 * fixValue turns a readable value, e.g. `0.0001` BTC, to the value in the smallest
 * unit, e.g. `10000` sats.
 *
 * @example
 * fixValue(0.0001, 8) = 10000;
 * @param value Value in the readable representation, e.g. `0.0001` BTC.
 * @param decimals The number of decimals to shift by, e.g. 8.
 */
export const fixValue = (value, decimals) => new BigNumber(value).shiftedBy(decimals).decimalPlaces(0);
/**
 * fixUTXO calls {{fixValue}} on the value of the UTXO.
 */
export const fixUTXO = (tx, decimals) => (Object.assign(Object.assign({}, tx), { amount: fixValue(tx.amount, decimals).toFixed() }));
/**
 * fixUTXOs maps over an array of UTXOs and calls {{fixValue}}.
 */
export const fixUTXOs = (utxos, decimals) => utxos.map((utxo) => fixUTXO(utxo, decimals));
const notNull = (x) => {
    if (x === undefined || x === null) {
        throw new Error(`Unexpected ${String(x)} value.`);
    }
    return x;
};
const withPriority = (api, defaultPriority = 0) => api.api &&
    api.priority !== undefined
    ? api
    : { api: api, priority: defaultPriority };
export class CombinedAPI {
    constructor(apis = [], { priority = 0 } = {}) {
        /**
         * Provide a new API to be used with the other APIs.
         *
         * @param api The API to add.
         * @param config Config for the API, including the priority.
         * @param config.priority Optionally set the priority of the API, where
         * a lower priority means it will be selected before other APIs.
         */
        this.withAPI = (api, { priority = 0 } = {}) => {
            this.apis.push(withPriority(api, priority));
            return this;
        };
        this.fetchHeight = () => __awaiter(this, void 0, void 0, function* () {
            return this.forEachAPI(
            // Filter APIs with `fetchHeight`.
            (api) => api.fetchHeight !== undefined, 
            // Call `fetchHeight` on the API.
            (api) => notNull(api.fetchHeight).bind(api)());
        });
        this.fetchUTXO = (txid, txindex) => __awaiter(this, void 0, void 0, function* () {
            return this.forEachAPI(
            // Filter APIs with `fetchUTXO`.
            (api) => api.fetchUTXO !== undefined, 
            // Call `fetchUTXO` on the API.
            (api) => notNull(api.fetchUTXO).bind(api)(txid, txindex));
        });
        this.fetchUTXOs = (address, confirmations) => __awaiter(this, void 0, void 0, function* () {
            return this.forEachAPI(
            // Filter APIs with `fetchUTXOs`.
            (api) => api.fetchUTXOs !== undefined, 
            // Call `fetchUTXOs` on the API.
            (api) => notNull(api.fetchUTXOs).bind(api)(address, confirmations));
        });
        this.fetchTXs = (address, confirmations) => __awaiter(this, void 0, void 0, function* () {
            return this.forEachAPI(
            // Filter APIs with `fetchTXs`.
            (api) => api.fetchTXs !== undefined, 
            // Call `fetchTXs` on the API.
            (api) => notNull(api.fetchTXs).bind(api)(address, confirmations));
        });
        this.broadcastTransaction = (hex) => __awaiter(this, void 0, void 0, function* () {
            return this.forEachAPI(
            // Filter APIs with `broadcastTransaction`.
            (api) => api.broadcastTransaction !== undefined, 
            // Call `broadcastTransaction` on the API.
            (api) => notNull(api.broadcastTransaction).bind(api)(hex));
        });
        this.forEachAPI = (filter, onAPI) => __awaiter(this, void 0, void 0, function* () {
            const apis = this.apis
                .map((api, index) => ({ api, index }))
                .filter(({ api }) => filter(api.api))
                .sort(({ api: a }, { api: b }) => 
            // Sort by priority, and randomly for the same priority.
            a.priority !== b.priority
                ? a.priority - b.priority
                : Math.random() * 2 - 1);
            if (!apis.length) {
                throw new Error(`No API available for call.`);
            }
            let firstError;
            const previousIndices = [];
            for (const { api, index } of apis) {
                try {
                    const result = yield onAPI(api.api);
                    // If any previous API failed, it may be down or rate limited,
                    // so its priority is reduced.
                    for (const previousIndex of previousIndices) {
                        this.apis[previousIndex].priority -= 5;
                    }
                    return result;
                }
                catch (error) {
                    previousIndices.push(index);
                    firstError =
                        firstError ||
                            (error instanceof Error
                                ? error
                                : new Error(utils.extractError(error)));
                }
            }
            throw firstError;
        });
        this.apis = apis.map((api) => withPriority(api, priority));
    }
}
//# sourceMappingURL=API.js.map