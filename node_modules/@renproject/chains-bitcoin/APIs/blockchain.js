"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Blockchain = exports.BlockchainNetwork = void 0;
const utils_1 = require("@renproject/utils");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const qs_1 = __importDefault(require("qs"));
const API_1 = require("./API");
var BlockchainNetwork;
(function (BlockchainNetwork) {
    BlockchainNetwork["Bitcoin"] = "btc";
    BlockchainNetwork["BitcoinCash"] = "bch";
    BlockchainNetwork["BitcoinTestnet"] = "btc-testnet";
    BlockchainNetwork["BitcoinCashTestnet"] = "bch-testnet";
})(BlockchainNetwork = exports.BlockchainNetwork || (exports.BlockchainNetwork = {}));
class Blockchain {
    constructor(network) {
        this.fetchHeight = async () => {
            const statsUrl = `${this.url}/block/best?notx=true`;
            const statsResponse = await utils_1.utils.GET(statsUrl);
            return statsResponse.height.toString();
        };
        this.fetchUTXO = async (txid, txindex) => {
            const url = `${this.url}/transaction/${txid}`;
            const response = await utils_1.utils.GET(`${url}`);
            return {
                txid: txid,
                txindex: txindex.toString(),
                amount: response.outputs[txindex].value.toString(),
                height: response.block.height
                    ? response.block.height.toString()
                    : null,
            };
        };
        this.fetchUTXOs = async (address, confirmations = 0, limit = 25, offset = 0) => this.fetchTXs(address, confirmations, limit, offset, true);
        this.fetchTXs = async (address, _confirmations = 0, limit = 25, offset = 0, onlyUnspent = false) => {
            const url = `${this.url}/address/${address}/transactions/full?limit=${limit}&offset=${offset}`;
            const response = await utils_1.utils.GET(url);
            let latestBlock;
            const received = [];
            for (const tx of response) {
                latestBlock =
                    latestBlock || new bignumber_js_1.default(await this.fetchHeight());
                for (let i = 0; i < tx.outputs.length; i++) {
                    const output = tx.outputs[i];
                    if (output.address === address &&
                        // If the onlyUnspent flag is true, check that the tx is unspent.
                        (!onlyUnspent || output.spent === false)) {
                        received.push({
                            txid: tx.txid,
                            amount: output.value.toString(),
                            txindex: i.toString(),
                            height: tx.block.height
                                ? tx.block.height.toString()
                                : null,
                        });
                    }
                }
            }
            return (received
                // .filter(
                //     (utxo) =>
                //         confirmations === 0 || utxo.confirmations >= confirmations,
                // )
                .sort(API_1.sortUTXOs));
        };
        this.broadcastTransaction = async (txHex) => {
            if (this.network !== BlockchainNetwork.Bitcoin) {
                throw new Error(`Broadcasting ${this.network} transactions not supported by endpoint.`);
            }
            const url = `https://blockchain.info/pushtx`;
            const response = await utils_1.utils.POST(url, qs_1.default.stringify({ tx: txHex }), 
            // URL-encoded params
            {
                headers: {
                    "content-type": "application/x-www-form-urlencoded",
                },
            });
            if (typeof response === "object" && response.error) {
                throw new Error(response.error);
            }
            // Check response type.
            return String(response);
        };
        this.network = network;
        this.url = `https://api.blockchain.info/haskoin-store/${network}`;
    }
}
exports.Blockchain = Blockchain;
//# sourceMappingURL=blockchain.js.map