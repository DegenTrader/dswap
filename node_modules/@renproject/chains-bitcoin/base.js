"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitcoinBaseChain = void 0;
const utils_1 = require("@renproject/utils");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bs58_1 = __importDefault(require("bs58"));
const wallet_address_validator_1 = require("wallet-address-validator");
const API_1 = require("./APIs/API");
const index_1 = require("./script/index");
const types_1 = require("./utils/types");
const utils_2 = require("./utils/utils");
/**
 * A base Bitcoin chain class that is extended by each Bitcoin chain/fork.
 */
class BitcoinBaseChain {
    constructor({ network }) {
        this.assets = {};
        this.configMap = {};
        this.api = new API_1.CombinedAPI();
        this.withAPI = (api, { priority = 0 } = {}) => {
            this.api.withAPI(api, { priority });
            return this;
        };
        this.getOutputPayload = (asset, _inputType, _outputType, toPayload) => {
            this._assertAssetIsSupported(asset);
            const address = toPayload.params.address;
            if (!address) {
                // throw new Error(`No ${this.chain} address specified.`);
                return undefined;
            }
            return {
                to: address,
                toBytes: this.addressToBytes(address),
                payload: new Uint8Array(),
            };
        };
        this.addressExplorerLink = (address) => {
            return this.network.explorer.address(address);
        };
        this.transactionExplorerLink = ({ txid, txHash, }) => {
            if (txHash) {
                return this.network.explorer.transaction(txHash);
            }
            else if (txid) {
                return this.network.explorer.transaction(this.txHashFromBytes(utils_1.utils.fromBase64(txid)));
            }
            return undefined;
        };
        this.getBalance = async (asset, address) => {
            this._assertAssetIsSupported(asset);
            if (!this.validateAddress(address)) {
                throw new Error(`Invalid address ${address}.`);
            }
            // TODO: Implement.
            return new bignumber_js_1.default(0);
        };
        this.validateAddress = (address) => {
            try {
                return (0, wallet_address_validator_1.validate)(address, this.network.nativeAsset.symbol, this.network.isTestnet ? "testnet" : "prod");
            }
            catch (error) {
                return false;
            }
        };
        this.addressToBytes = (address) => {
            return (0, utils_2.addressToBytes)(address);
        };
        this.addressFromBytes = (bytes) => {
            return bs58_1.default.encode(bytes);
        };
        this.txHashToBytes = (txHash) => {
            return (0, utils_2.txHashToBytes)(txHash);
        };
        this.txHashFromBytes = (bytes) => {
            return (0, utils_2.txHashFromBytes)(bytes);
        };
        this.validateTransaction = (transaction) => {
            return ((utils_1.utils.isDefined(transaction.txid) ||
                utils_1.utils.isDefined(transaction.txHash)) &&
                (transaction.txHash
                    ? utils_1.utils.isHex(transaction.txHash, {
                        length: 32,
                    })
                    : true) &&
                (transaction.txid
                    ? utils_1.utils.isURLBase64(transaction.txid, {
                        length: 32,
                    })
                    : true) &&
                (transaction.txindex
                    ? !new bignumber_js_1.default(transaction.txindex).isNaN()
                    : true) &&
                (transaction.txHash && transaction.txid
                    ? utils_1.utils.toURLBase64((0, utils_2.txHashToBytes)(transaction.txHash)) ===
                        transaction.txid
                    : true));
        };
        /**
         * See [[LockChain.isLockAsset]].
         */
        this.isLockAsset = (asset) => {
            return asset === this.network.nativeAsset.symbol;
        };
        this.isDepositAsset = (asset) => {
            this._assertAssetIsSupported(asset);
            return true;
        };
        this._assertAssetIsSupported = (asset) => {
            if (!this.isLockAsset(asset)) {
                throw new Error(`Asset ${asset} not supported on ${this.chain}.`);
            }
        };
        /**
         * See [[LockChain.assetDecimals]].
         */
        this.assetDecimals = (asset) => {
            this._assertAssetIsSupported(asset);
            return 8;
        };
        this.watchForDeposits = async (asset, fromPayload, address, onInput, _removeInput, listenerCancelled) => {
            this._assertAssetIsSupported(asset);
            if (fromPayload.chain !== this.chain) {
                throw new Error(`Invalid payload for chain ${fromPayload.chain} instead of ${this.chain}.`);
            }
            // If the payload is a transaction, submit it to onInput and then loop
            // indefinitely.
            if (fromPayload.type === "transaction") {
                const inputTx = fromPayload.params.tx;
                if (inputTx.amount === undefined) {
                    while (true) {
                        try {
                            const tx = await this.api.fetchUTXO(inputTx.txHash, inputTx.txindex);
                            onInput({
                                chain: this.chain,
                                txid: utils_1.utils.toURLBase64(utils_1.utils.fromHex(tx.txid).reverse()),
                                txHash: tx.txid,
                                txindex: tx.txindex,
                                explorerLink: this.transactionExplorerLink({
                                    txHash: tx.txid,
                                }) || "",
                                asset,
                                amount: tx.amount,
                            });
                            break;
                        }
                        catch (error) {
                            console.error(error);
                        }
                    }
                    while (true) {
                        await utils_1.utils.sleep(15 * utils_1.utils.sleep.SECONDS);
                    }
                }
            }
            try {
                const txs = await utils_1.utils.tryNTimes(async () => this.api.fetchTXs(address), 2);
                txs.map((tx) => onInput({
                    chain: this.chain,
                    txid: utils_1.utils.toURLBase64(utils_1.utils.fromHex(tx.txid).reverse()),
                    txHash: tx.txid,
                    txindex: tx.txindex,
                    explorerLink: this.transactionExplorerLink({
                        txHash: tx.txid,
                    }) || "",
                    asset,
                    amount: tx.amount,
                }));
            }
            catch (error) {
                // Ignore error and fallback to getUTXOs.
            }
            while (true) {
                if (listenerCancelled()) {
                    return;
                }
                try {
                    const utxos = await this.api.fetchUTXOs(address);
                    utxos.map((tx) => onInput({
                        chain: this.chain,
                        txid: utils_1.utils.toURLBase64(utils_1.utils.fromHex(tx.txid).reverse()),
                        txHash: tx.txid,
                        txindex: tx.txindex,
                        explorerLink: this.transactionExplorerLink({
                            txHash: tx.txid,
                        }) || "",
                        asset,
                        amount: tx.amount,
                    }));
                }
                catch (error) {
                    console.error(error);
                }
                await utils_1.utils.sleep(15 * utils_1.utils.sleep.SECONDS);
            }
        };
        /**
         * See [[LockChain.transactionConfidence]].
         */
        this.transactionConfidence = async (transaction) => {
            const { height } = await this.api.fetchUTXO(transaction.txHash, transaction.txindex);
            if (!height) {
                return new bignumber_js_1.default(0);
            }
            else {
                const latestHeight = new bignumber_js_1.default(await this.api.fetchHeight());
                return latestHeight.minus(height).plus(1);
            }
        };
        /**
         * See [[LockChain.getGatewayAddress]].
         */
        this.createGatewayAddress = (asset, fromPayload, shardPublicKey, gHash) => {
            this._assertAssetIsSupported(asset);
            if (fromPayload.chain !== this.chain) {
                throw new Error(`Invalid payload for chain ${fromPayload.chain} instead of ${this.chain}.`);
            }
            return this.addressFromBytes((0, index_1.createAddressArray)((0, utils_2.hash160)(shardPublicKey), gHash, this.network.p2shPrefix));
        };
        // Methods for initializing mints and burns ////////////////////////////////
        /**
         * When burning, you can call `Bitcoin.Address("...")` to make the address
         * available to the burn params.
         *
         * @category Main
         */
        this.Address = (address) => {
            // Type validation
            (0, utils_1.assertType)("string", { address });
            if (!this.validateAddress(address)) {
                throw utils_1.ErrorWithCode.updateError(new Error(`Invalid ${this.chain} address: ${String(address)}`), utils_1.RenJSError.PARAMETER_ERROR);
            }
            return {
                chain: this.chain,
                type: "address",
                params: {
                    address,
                },
            };
        };
        /**
         * When burning, you can call `Bitcoin.Address("...")` to make the address
         * available to the burn params.
         *
         * @category Main
         */
        this.GatewayAddress = () => {
            return {
                chain: this.chain,
                type: "gatewayAddress",
            };
        };
        /**
         * Import an existing Bitcoin transaction instead of watching for deposits
         * to a gateway address.
         *
         * @example
         * bitcoin.Transaction({
         *   txHash: "a1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d",
         *   txindex: "0"
         * })
         */
        this.Transaction = (partialTx) => {
            return {
                chain: this.chain,
                type: "transaction",
                params: {
                    tx: (0, utils_1.populateChainTransaction)({
                        partialTx,
                        chain: this.chain,
                        txHashToBytes: utils_2.txHashToBytes,
                        txHashFromBytes: utils_2.txHashFromBytes,
                        explorerLink: this.transactionExplorerLink,
                    }),
                },
            };
        };
        this.toSats = (value) => {
            return new bignumber_js_1.default(value).shiftedBy(8).decimalPlaces(0).toFixed();
        };
        this.fromSats = (value) => {
            return new bignumber_js_1.default(value).shiftedBy(-8).toFixed();
        };
        const networkConfig = (0, types_1.isBitcoinNetworkConfig)(network)
            ? network
            : this.configMap[network];
        if (!networkConfig) {
            if (typeof network === "string") {
                throw new Error(`Unknown network ${network}.`);
            }
            else {
                throw new Error(`Invalid network config.`);
            }
        }
        this.network = networkConfig;
        this.chain = this.network.selector;
        for (const provider of this.network.providers) {
            this.withAPI(provider);
        }
    }
}
exports.BitcoinBaseChain = BitcoinBaseChain;
BitcoinBaseChain.configMap = {};
//# sourceMappingURL=base.js.map