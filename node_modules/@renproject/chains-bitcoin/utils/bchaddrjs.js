"use strict";
// MIT License
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeBitcoinCashAddress = void 0;
// Copyright (c) 2018-2020 Emilio Almansi
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
const utils_1 = require("@renproject/utils");
const bchaddrjs_1 = require("bchaddrjs");
const bs58_1 = __importDefault(require("bs58"));
const bs58check_1 = __importDefault(require("bs58check"));
const cashaddrjs_1 = __importStar(require("cashaddrjs"));
var Format;
(function (Format) {
    Format["Legacy"] = "legacy";
    Format["Bitpay"] = "bitpay";
    Format["Cashaddr"] = "cashaddr";
})(Format || (Format = {}));
var Network;
(function (Network) {
    Network["Mainnet"] = "mainnet";
    Network["Testnet"] = "testnet";
})(Network || (Network = {}));
var Type;
(function (Type) {
    Type["P2PKH"] = "p2pkh";
    Type["P2SH"] = "p2sh";
})(Type || (Type = {}));
const VERSION_BYTE = {
    [Format.Legacy]: {
        [Network.Mainnet]: {
            [Type.P2PKH]: 0,
            [Type.P2SH]: 5,
        },
        [Network.Testnet]: {
            [Type.P2PKH]: 111,
            [Type.P2SH]: 196,
        },
    },
    [Format.Bitpay]: {
        [Network.Mainnet]: {
            [Type.P2PKH]: 28,
            [Type.P2SH]: 40,
        },
        [Network.Testnet]: {
            [Type.P2PKH]: 111,
            [Type.P2SH]: 196,
        },
    },
};
const BASE_58_CHECK_PAYLOAD_LENGTH = 21;
const decodeBase58Address = (address) => {
    try {
        const payload = bs58check_1.default.decode(address);
        if (payload.length !== BASE_58_CHECK_PAYLOAD_LENGTH) {
            throw new bchaddrjs_1.InvalidAddressError();
        }
        const versionByte = payload[0];
        const hash = Array.prototype.slice.call(payload, 1);
        switch (versionByte) {
            case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2PKH]:
                return {
                    hash: hash,
                    format: Format.Legacy,
                    network: Network.Mainnet,
                    type: Type.P2PKH,
                };
            case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2SH]:
                return {
                    hash: hash,
                    format: Format.Legacy,
                    network: Network.Mainnet,
                    type: Type.P2SH,
                };
            case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2PKH]:
                return {
                    hash: hash,
                    format: Format.Legacy,
                    network: Network.Testnet,
                    type: Type.P2PKH,
                };
            case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2SH]:
                return {
                    hash: hash,
                    format: Format.Legacy,
                    network: Network.Testnet,
                    type: Type.P2SH,
                };
            case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2PKH]:
                return {
                    hash: hash,
                    format: Format.Bitpay,
                    network: Network.Mainnet,
                    type: Type.P2PKH,
                };
            case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2SH]:
                return {
                    hash: hash,
                    format: Format.Bitpay,
                    network: Network.Mainnet,
                    type: Type.P2SH,
                };
        }
    }
    catch (error) {
        // Ignore error.
    }
    throw new bchaddrjs_1.InvalidAddressError();
};
const decodeCashAddressWithPrefix = (address) => {
    try {
        const decoded = cashaddrjs_1.default.decode(address);
        const hash = Array.prototype.slice.call(decoded.hash, 0);
        const type = decoded.type === "P2PKH" ? Type.P2PKH : Type.P2SH;
        switch (decoded.prefix) {
            case "bitcoincash":
                return {
                    hash: hash,
                    format: Format.Cashaddr,
                    network: Network.Mainnet,
                    type: type,
                };
            case "bchtest":
            case "bchreg":
                return {
                    hash: hash,
                    format: Format.Cashaddr,
                    network: Network.Testnet,
                    type: type,
                };
        }
    }
    catch (error) {
        // Ignore error.
    }
    throw new bchaddrjs_1.InvalidAddressError();
};
const decodeCashAddress = (address) => {
    if (address.indexOf(":") !== -1) {
        try {
            return decodeCashAddressWithPrefix(address);
        }
        catch (error) {
            // Ignore error.
        }
    }
    else {
        const prefixes = ["bitcoincash", "bchtest", "bchreg"];
        for (let i = 0; i < prefixes.length; ++i) {
            try {
                const prefix = prefixes[i];
                return decodeCashAddressWithPrefix(prefix + ":" + address);
            }
            catch (error) {
                // Ignore error.
            }
        }
    }
    throw new bchaddrjs_1.InvalidAddressError();
};
const getTypeBits = (type) => {
    switch (type.toLowerCase()) {
        case Type.P2PKH:
            return 0;
        case Type.P2SH:
            return 8;
        default:
            throw new cashaddrjs_1.ValidationError("Invalid type: " + type + ".");
    }
};
const decodeBitcoinCashAddress = (address) => {
    try {
        // Validate checksum:
        const _check = decodeBase58Address(address);
        return new Uint8Array(bs58_1.default.decode(address));
    }
    catch (error) {
        // Ignore error.
    }
    try {
        const { hash, type } = decodeCashAddress(address);
        return utils_1.utils.concat([
            new Uint8Array([getTypeBits(type)]),
            new Uint8Array(hash),
        ]);
    }
    catch (error) {
        // Ignore error.
    }
    throw new bchaddrjs_1.InvalidAddressError();
};
exports.decodeBitcoinCashAddress = decodeBitcoinCashAddress;
//# sourceMappingURL=bchaddrjs.js.map