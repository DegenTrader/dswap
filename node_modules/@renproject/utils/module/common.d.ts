import { ChainTransaction } from "./types/chain";
/**
 * Decode a RenVM selector into the asset, the from-chain and the to-chain.
 *
 * @example
 * decodeRenVMSelector("BTC/toEthereum", "Bitcoin")
 * // { asset: "BTC", from: "Bitcoin", to: "Ethereum" }
 *
 * decodeRenVMSelector("DAI/toFantom", "Ethereum")
 * // { asset: "DAI", from: "Ethereum", to: "Fantom" }
 *
 * @param selector A RenVM selector
 * @param assetChain The chain of the selector's asset
 * @returns An object containing the asset and to and from chains.
 */
export declare const decodeRenVMSelector: (selector: string, assetChain: string) => {
    asset: string;
    from: string;
    to: string;
};
export declare const isEmptySignature: (sig: Uint8Array) => boolean;
/**
 * Normalize the `s` and `v` values of a secp256k1 signature.
 *
 * This includes:
 * 1) ensuring the `v` value is either 27 or 28
 * 2) ensuring that `s` is less than secp256k1n/2
 *
 * This is required before a mint or release signature can be submitted to a
 * MintGateway or LockGateway.
 *
 * @param signature The `r`, `s` and `v` values concatenated as a Uint8Array.
 * @returns The signature in the same format, with normalized values.
 */
export declare const normalizeSignature: (signature: Uint8Array) => Uint8Array;
/** Convert a partial chain transaction to a chain transaction with all its fields. */
export declare const populateChainTransaction: ({ partialTx, chain, txHashToBytes, txHashFromBytes, explorerLink, defaultTxindex, }: {
    partialTx: Partial<ChainTransaction> & ({
        txid: string;
    } | {
        txHash: string;
    });
    chain: string;
    txHashToBytes: (txHash: string) => Uint8Array;
    txHashFromBytes: (bytes: Uint8Array) => string;
    explorerLink: (transaction: Partial<ChainTransaction> & ({
        txid: string;
    } | {
        txHash: string;
    })) => string | undefined;
    defaultTxindex?: string | undefined;
}) => ChainTransaction;
//# sourceMappingURL=common.d.ts.map