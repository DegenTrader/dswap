var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { isDefined, newPromiEvent } from "./internal/common";
import { sleep } from "./internal/sleep";
import { eventEmitter, } from "./types/eventEmitter";
export var ChainTransactionStatus;
(function (ChainTransactionStatus) {
    // The transaction hasn't been submitted - note that the transaction may
    // have incomplete dependencies which aren't reflected in this status.
    ChainTransactionStatus["Ready"] = "ready";
    // The transaction has been submitted but has not reached the required
    // confirmation threshold to be considered done. Note that it may still
    // have one or more confirmations on the chain.
    ChainTransactionStatus["Confirming"] = "confirming";
    // The transaction was executed successfully and has reached the required
    // number of confirmations.
    ChainTransactionStatus["Done"] = "done";
    // The transaction was submitted on-chain but its execution failed.
    ChainTransactionStatus["Reverted"] = "reverted";
})(ChainTransactionStatus || (ChainTransactionStatus = {}));
/**
 * Allow overwriting the `transaction` field of a TxWaiter instance.
 * This is used so the same TxWaiter instance can paired with different
 * InputChainTransaction objects that are all extensions of the TxWaiter's
 * original ChainTransaction object.
 */
export class TxWaiterProxy {
    constructor(txWaiter, transaction) {
        this._wait = (target) => {
            const promiEvent = newPromiEvent(this._eventEmitter);
            (() => __awaiter(this, void 0, void 0, function* () {
                return yield this._txWaiter.wait(target);
            }))()
                .then(promiEvent.resolve)
                .catch(promiEvent.reject);
            return promiEvent;
        };
        /**
         * Proxy handler to call the promise or eventEmitter methods
         */
        this.proxyHandler = (target, name) => {
            if (name === "transaction") {
                return target._transaction;
            }
            if (name === "progress") {
                return Object.assign(Object.assign({}, target._txWaiter[name]), { transaction: target._transaction });
            }
            if (name === "eventEmitter") {
                return target._eventEmitter;
            }
            if (name === "wait") {
                return target._wait.bind(target);
            }
            return target._txWaiter[name];
        };
        this._txWaiter = txWaiter;
        this._transaction = transaction;
        this._eventEmitter = eventEmitter();
        txWaiter.eventEmitter.on("progress", (progress) => {
            this._eventEmitter.emit("progress", Object.assign(Object.assign({}, progress), { transaction: this._transaction }));
        });
        return new Proxy(this, {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            get: this.proxyHandler,
        });
    }
}
/**
 * The DefaultTxWaiter is a helper for when a chain transaction has already
 * been submitted.
 */
export class DefaultTxWaiter {
    /**
     * Requires a submitted chainTransaction, a chain object and the target
     * confirmation count.
     */
    constructor({ chainTransaction, chain, target, onFirstProgress, }) {
        this.updateProgress = (progress) => {
            this.progress = Object.assign(Object.assign({}, this.progress), progress);
            this.eventEmitter.emit("progress", this.progress);
            return this.progress;
        };
        /**
         * The transaction can be set at a later point. This is for situations where
         * its known that a transaction will already have been submitted, but its
         * hash isn't available yet. For example, a release transaction submitted
         * by RenVM.
         */
        this.setTransaction = (chainTransaction) => {
            return this.updateProgress({
                transaction: chainTransaction,
                status: chainTransaction && chainTransaction.txid === ""
                    ? ChainTransactionStatus.Done
                    : ChainTransactionStatus.Confirming,
            });
        };
        this.wait = (target) => {
            const promiEvent = newPromiEvent(this.eventEmitter);
            (() => __awaiter(this, void 0, void 0, function* () {
                const tx = this.progress.transaction;
                if (!tx) {
                    throw new Error(`Must call ".submit" first.`);
                }
                target = isDefined(target) ? target : this.progress.target;
                // If the txid is missing, then assume that the transaction
                // is confirmed. In some situations its known that a transaction
                // has taken place (e.g. by looking at the current state of the
                // chain) but there's no way of finding the transaction's details.
                // In this case, the txid will be set to "".
                if (tx.txid === "") {
                    this.updateProgress(Object.assign(Object.assign({}, this.progress), { confirmations: target, status: ChainTransactionStatus.Done }));
                    return this.progress;
                }
                let currentConfidenceRatio = -1;
                while (true) {
                    try {
                        const confidence = (yield this._chain.transactionConfidence(tx)).toNumber();
                        const confidenceRatio = target === 0 ? 1 : confidence / target;
                        // The confidence has increased.
                        if (confidenceRatio > currentConfidenceRatio) {
                            if (this._onFirstProgress) {
                                yield this._onFirstProgress(tx);
                                this._onFirstProgress = undefined;
                            }
                            if (confidenceRatio >= 1) {
                                // Done.
                                this.updateProgress(Object.assign(Object.assign({}, this.progress), { confirmations: confidence, status: ChainTransactionStatus.Done }));
                                break;
                            }
                            else {
                                // Update progress.
                                currentConfidenceRatio = confidenceRatio;
                                this.updateProgress(Object.assign(Object.assign({}, this.progress), { confirmations: confidence }));
                            }
                        }
                    }
                    catch (error) {
                        console.error(error);
                    }
                    yield sleep(15 * sleep.SECONDS);
                }
                return this.progress;
            }))()
                .then(promiEvent.resolve)
                .catch(promiEvent.reject);
            return promiEvent;
        };
        this._chain = chain;
        this._onFirstProgress = onFirstProgress;
        this.chain = chain.chain;
        this.eventEmitter = eventEmitter();
        this.progress = Object.assign({ chain: chain.chain, status: chainTransaction && chainTransaction.txid === ""
                ? ChainTransactionStatus.Done
                : ChainTransactionStatus.Confirming, target }, (chainTransaction ? { transaction: chainTransaction } : {}));
    }
}
//# sourceMappingURL=txSubmitter.js.map