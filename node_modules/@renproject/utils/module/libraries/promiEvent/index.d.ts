/**
 * @file PromiEvent.js
 * @author Fabian Vogelsteller <fabian@ethereum.org>, Samuel Furter <samuel@ethereum.org>
 * 2018
 */
import { EventEmitter } from "events";
import { EventEmitterTyped } from "../../types/eventEmitter";
/** PromiEvent implementation, modified from the Web3 PromiEvent. */
export declare class Web3PromiEvent<T, EventTypes extends {
    [event: string]: any[];
} = {}> extends EventEmitterTyped<EventTypes> {
    readonly [Symbol.toStringTag]: "Promise";
    readonly promise: Promise<T>;
    resolve: (value: T | PromiseLike<T>) => void;
    reject: (reason?: any) => void;
    eventEmitter: EventEmitterTyped<EventTypes>;
    private _cancelled;
    readonly emit: <Event extends keyof EventTypes>(event: Event, ...args: EventTypes[Event]) => boolean;
    readonly removeListener: EventEmitter["removeListener"];
    readonly on: <Event extends keyof EventTypes>(event: Event, callback: (...values: EventTypes[Event]) => void | Promise<void>) => this;
    readonly once: <Event extends keyof EventTypes>(event: Event, callback: (...values: EventTypes[Event]) => void | Promise<void>) => this;
    readonly listenerCount: (event: string | symbol) => number;
    readonly _cancel: () => void;
    readonly _resume: () => void;
    readonly _isCancelled: () => boolean;
    readonly then: Promise<T>["then"];
    readonly catch: Promise<T>["catch"];
    readonly finally: Promise<T>["finally"];
    /**
     * Sets up the event emitter and the promise, as well as a proxy handler
     * for routing method calls to the promise or event emitter.
     */
    constructor(eventEmitter?: EventEmitterTyped<EventTypes>);
    /**
     * Proxy handler to call the promise or eventEmitter methods
     */
    proxyHandler: (target: Web3PromiEvent<T, EventTypes>, name: string) => unknown;
}
//# sourceMappingURL=index.d.ts.map