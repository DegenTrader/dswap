import { Chain, ChainTransaction, SyncOrPromise } from "./types/chain";
import { EventEmitterTyped, PromiEvent } from "./types/eventEmitter";
export declare enum ChainTransactionStatus {
    Ready = "ready",
    Confirming = "confirming",
    Done = "done",
    Reverted = "reverted"
}
export interface ChainTransactionProgress {
    chain: string;
    status: ChainTransactionStatus;
    target: number;
    confirmations?: number;
    transaction?: ChainTransaction;
    /**
     * If the status is Reverted, `revertReason` should be set to accompanying
     * error message if there is one.
     */
    revertReason?: string;
    /**
     * If the transaction is replaced/sped-up, `replaced` should be set to the
     * old transaction details.
     */
    replaced?: ChainTransaction;
}
export interface TxWaiter<Progress extends ChainTransactionProgress = ChainTransactionProgress> {
    chain: string;
    progress: Progress;
    eventEmitter: EventEmitterTyped<{
        progress: [Progress];
    }>;
    setTransaction(chainTransaction: ChainTransaction): SyncOrPromise<ChainTransactionProgress>;
    /**
     * Submit the transaction to the chain.
     */
    submit?(params?: {
        overrides?: {
            [key: string]: any;
        };
        txConfig?: any;
    }): PromiEvent<Progress, {
        progress: [Progress];
    }>;
    export?(params?: {
        overrides?: {
            [key: string]: any;
        };
        txConfig?: any;
    }): SyncOrPromise<any>;
    /**
     * Wait for the required finality / number of confirmations.
     * The target can optionally be overridden.
     */
    wait(targetOverride?: number): PromiEvent<Progress, {
        progress: [Progress];
    }>;
}
/**
 * TxSubmitter is a standard interface across chains to allow for submitting
 * transactions and waiting for finality. The `wait` and `submit` methods
 * emit a "progress" event which is standard across chains.
 */
export interface TxSubmitter<Progress extends ChainTransactionProgress = ChainTransactionProgress, TxConfig = {}, TxExport = {}> extends TxWaiter<Progress> {
    /**
     * Submit the transaction to the chain.
     */
    submit(params?: {
        overrides?: {
            [key: string]: any;
        };
        txConfig?: TxConfig;
    }): PromiEvent<Progress, {
        progress: [Progress];
    }>;
    /**
     * Export the raw unsigned transaction that would be signed/submitted by
     * `submit`.
     */
    export(params?: {
        overrides?: {
            [key: string]: any;
        };
        txConfig?: TxConfig;
    }): SyncOrPromise<TxExport>;
}
/**
 * Allow overwriting the `transaction` field of a TxWaiter instance.
 * This is used so the same TxWaiter instance can paired with different
 * InputChainTransaction objects that are all extensions of the TxWaiter's
 * original ChainTransaction object.
 */
export declare class TxWaiterProxy {
    private _txWaiter;
    private _transaction;
    private _eventEmitter;
    constructor(txWaiter: TxWaiter, transaction: ChainTransaction);
    _wait: (target?: number) => PromiEvent<ChainTransactionProgress, {
        progress: [ChainTransactionProgress];
    }>;
    /**
     * Proxy handler to call the promise or eventEmitter methods
     */
    proxyHandler: (target: TxWaiterProxy, name: string) => unknown;
}
/**
 * The DefaultTxWaiter is a helper for when a chain transaction has already
 * been submitted.
 */
export declare class DefaultTxWaiter implements TxWaiter {
    private _chain;
    chain: string;
    progress: ChainTransactionProgress;
    eventEmitter: EventEmitterTyped<{
        progress: [ChainTransactionProgress];
    }>;
    private _onFirstProgress?;
    private updateProgress;
    /**
     * Requires a submitted chainTransaction, a chain object and the target
     * confirmation count.
     */
    constructor({ chainTransaction, chain, target, onFirstProgress, }: {
        chainTransaction?: ChainTransaction;
        chain: Chain;
        target: number;
        onFirstProgress?: (tx: ChainTransaction) => SyncOrPromise<void>;
    });
    /**
     * The transaction can be set at a later point. This is for situations where
     * its known that a transaction will already have been submitted, but its
     * hash isn't available yet. For example, a release transaction submitted
     * by RenVM.
     */
    setTransaction: (chainTransaction: ChainTransaction) => ChainTransactionProgress;
    wait: (target?: number) => PromiEvent<ChainTransactionProgress, {
        progress: [ChainTransactionProgress];
    }>;
}
//# sourceMappingURL=txSubmitter.d.ts.map