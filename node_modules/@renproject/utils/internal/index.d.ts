export declare const utils: {
    sleep: {
        (ms: number): Promise<void>;
        SECONDS: number;
        MINUTES: number;
    };
    hasOwnProperty: <T>(object: any, property: keyof T) => object is T;
    invalidError: (errorMessage: string) => boolean;
    extractError: (error: unknown) => string;
    DEFAULT_TIMEOUT: number;
    GET: <T_1 = unknown, D = any>(url: string, config?: import("axios").AxiosRequestConfig<D> | undefined) => Promise<T_1>;
    POST: <T_2 = unknown, D_1 = any>(url: string, data?: D_1 | undefined, config?: import("axios").AxiosRequestConfig<D_1> | undefined) => Promise<T_2>;
    keccak256: (...msg: Uint8Array[]) => Uint8Array;
    sha256: (...msg: Uint8Array[]) => Uint8Array;
    assert: (assertion: boolean, sentence?: string | undefined) => assertion is true;
    assertType: <T_3 = unknown>(type: string, objects: {
        [value: string]: T_3;
    }) => objects is {
        [value: string]: T_3;
    };
    assertObject: <T_4 extends object>(fieldTypes: { [P in keyof T_4]: string | {}; }, objects: {
        [key: string]: T_4;
    }) => boolean;
    tryNTimes: <T_5>(fnCall: (attempt: number, retries: number) => Promise<T_5>, retries: number, timeout?: number, logger?: import("..").Logger | undefined) => Promise<T_5>;
    tryIndefinitely: <T_6>(fnCall: (attempt: number, retries: number) => Promise<T_6>) => Promise<T_6>;
    isDefined: <T_7>(x: T_7 | null | undefined) => x is T_7;
    doesntError: <T_8 extends unknown[]>(f: (...p: T_8) => boolean | void) => (...p: T_8) => boolean;
    padUint8Array: (array: Uint8Array, n: number) => Uint8Array;
    toNBytes: (input: string | number | Uint8Array | import("bignumber.js").default, n: number, endian?: "be" | "le") => Uint8Array;
    fromBytes: (input: Uint8Array, endian?: "be" | "le") => import("bignumber.js").default;
    memoize: <Params extends unknown[], Result>(fn: (...params: Params) => Promise<Result>, { expiry, entryLimit }?: {
        expiry?: number | false;
        entryLimit?: number;
    }) => (...params: Params) => Promise<Result>;
    strip0x: (hex: string) => string;
    toHex: (array: Uint8Array) => string;
    Ox: (hexInput: string | number | Uint8Array, { prefix }?: {
        prefix: string;
    }) => string;
    fromHex: (hexString: string) => Uint8Array;
    toUTF8String: (input: Uint8Array) => string;
    fromUTF8String: (input: string) => Uint8Array;
    fromBase64: (base64String: string) => Uint8Array;
    toBase64: (input: Uint8Array) => string;
    toURLBase64: (input: Uint8Array) => string;
    isBase64: (input: string, options?: {
        length?: number | undefined;
    } | undefined) => boolean;
    isURLBase64: (input: string, options?: {
        length?: number | undefined;
    } | undefined) => boolean;
    isHex: (input: string, options?: {
        prefix?: true | undefined;
        length?: number | undefined;
        uppercase?: boolean | undefined;
    } | undefined) => boolean;
    newPromiEvent: <T_9, EventTypes extends {
        [event: string]: any[];
    } = {}>(eventEmitter?: import("..").EventEmitterTyped<EventTypes> | undefined) => import("..").PromiEvent<T_9, EventTypes>;
    concat: (uint8Arrays: Uint8Array[]) => Uint8Array;
};
//# sourceMappingURL=index.d.ts.map