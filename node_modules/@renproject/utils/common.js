"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.populateChainTransaction = exports.normalizeSignature = exports.isEmptySignature = exports.decodeRenVMSelector = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const internal_1 = require("./internal");
/**
 * Decode a RenVM selector into the asset, the from-chain and the to-chain.
 *
 * @example
 * decodeRenVMSelector("BTC/toEthereum", "Bitcoin")
 * // { asset: "BTC", from: "Bitcoin", to: "Ethereum" }
 *
 * decodeRenVMSelector("DAI/toFantom", "Ethereum")
 * // { asset: "DAI", from: "Ethereum", to: "Fantom" }
 *
 * @param selector A RenVM selector
 * @param assetChain The chain of the selector's asset
 * @returns An object containing the asset and to and from chains.
 */
const decodeRenVMSelector = (selector, assetChain) => {
    const regex = 
    // Regular Expression to match selectors in the form of
    // ASSET/fromCHAINtoCHAIN, ASSET/fromCHAIN or ASSET/toCHAIN.
    // ^(  ASSET )/[      [from(        CHAIN      ) _   to(   CHAIN  )] OR [from( CHAIN )] OR ( to(  CHAIN  ))]$
    /^([a-zA-Z]+)\/(?:(?:(?:from([a-zA-Z]+?(?=_to)))\_(?:to([a-zA-Z]+))?)|(?:from([a-zA-Z]+))|(?:to([a-zA-Z]+)))$/;
    const match = regex.exec(selector);
    if (!match) {
        throw new Error(`Invalid selector format '${selector}'.`);
    }
    const [_, asset, burnAndMintFrom, burnAndMintTo, burnFrom, mintTo] = match;
    return {
        asset,
        from: burnAndMintFrom || burnFrom || assetChain,
        to: burnAndMintTo || mintTo || assetChain,
    };
};
exports.decodeRenVMSelector = decodeRenVMSelector;
const EMPTY_SIGNATURE = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
const isEmptySignature = (sig) => internal_1.utils.toURLBase64(sig) === EMPTY_SIGNATURE;
exports.isEmptySignature = isEmptySignature;
/**
 * Normalize the `s` and `v` values of a secp256k1 signature.
 *
 * This includes:
 * 1) ensuring the `v` value is either 27 or 28
 * 2) ensuring that `s` is less than secp256k1n/2
 *
 * This is required before a mint or release signature can be submitted to a
 * MintGateway or LockGateway.
 *
 * @param signature The `r`, `s` and `v` values concatenated as a Uint8Array.
 * @returns The signature in the same format, with normalized values.
 */
const normalizeSignature = (signature) => {
    internal_1.utils.assertType("Uint8Array", { signature });
    // The signature is empty, so we should modify it.
    if ((0, exports.isEmptySignature)(signature)) {
        return signature;
    }
    const r = signature.slice(0, 32);
    const s = signature.slice(32, 64);
    let v = signature.slice(64, 65)[0];
    let sBN = new bignumber_js_1.default(internal_1.utils.Ox(s), 16);
    // Normalize v value
    v = ((v || 0) % 27) + 27;
    // The size of the field that secp256k1 is defined over.
    const secp256k1n = new bignumber_js_1.default("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", 16);
    // For a given key, there are two valid signatures for each signed message.
    // We always take the one with the lower `s`.
    // Check if s > secp256k1n/2 (57896044618658097711785492504343953926418782139537452191302581570759080747168.5)
    if (sBN.gt(secp256k1n.div(2))) {
        // Take s = -s % secp256k1n
        sBN = secp256k1n.minus(sBN);
        // Switch v
        v = v === 27 ? 28 : 27;
    }
    return internal_1.utils.concat([r, internal_1.utils.toNBytes(sBN, 32), new Uint8Array([v])]);
};
exports.normalizeSignature = normalizeSignature;
/** Convert a partial chain transaction to a chain transaction with all its fields. */
const populateChainTransaction = ({ partialTx, chain, txHashToBytes, txHashFromBytes, explorerLink, defaultTxindex, }) => {
    const maybeTxHash = partialTx.txHash;
    const txid = partialTx.txid ||
        (maybeTxHash && internal_1.utils.toURLBase64(txHashToBytes(maybeTxHash)));
    const txHash = maybeTxHash ||
        (partialTx.txid && txHashFromBytes(internal_1.utils.fromBase64(partialTx.txid)));
    if (!txid || !txHash) {
        throw new Error(`Must provide either 'txid' or 'txHash' for ${chain} transaction.`);
    }
    if (partialTx.chain && partialTx.chain !== chain) {
        throw new Error(`Unexpected chain (expected '${chain}', got '${partialTx.chain}').`);
    }
    const txindex = partialTx.txindex || defaultTxindex;
    if (!txindex) {
        throw new Error(`Must provide txindex for ${chain} transaction.`);
    }
    const tx = Object.assign(Object.assign({}, partialTx), { chain,
        txid,
        txHash,
        txindex });
    return Object.assign(Object.assign({}, tx), { explorerLink: explorerLink(tx) || "" });
};
exports.populateChainTransaction = populateChainTransaction;
//# sourceMappingURL=common.js.map