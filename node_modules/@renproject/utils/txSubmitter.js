"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultTxWaiter = exports.TxWaiterProxy = exports.ChainTransactionStatus = void 0;
const common_1 = require("./internal/common");
const sleep_1 = require("./internal/sleep");
const eventEmitter_1 = require("./types/eventEmitter");
var ChainTransactionStatus;
(function (ChainTransactionStatus) {
    // The transaction hasn't been submitted - note that the transaction may
    // have incomplete dependencies which aren't reflected in this status.
    ChainTransactionStatus["Ready"] = "ready";
    // The transaction has been submitted but has not reached the required
    // confirmation threshold to be considered done. Note that it may still
    // have one or more confirmations on the chain.
    ChainTransactionStatus["Confirming"] = "confirming";
    // The transaction was executed successfully and has reached the required
    // number of confirmations.
    ChainTransactionStatus["Done"] = "done";
    // The transaction was submitted on-chain but its execution failed.
    ChainTransactionStatus["Reverted"] = "reverted";
})(ChainTransactionStatus = exports.ChainTransactionStatus || (exports.ChainTransactionStatus = {}));
/**
 * Allow overwriting the `transaction` field of a TxWaiter instance.
 * This is used so the same TxWaiter instance can paired with different
 * InputChainTransaction objects that are all extensions of the TxWaiter's
 * original ChainTransaction object.
 */
class TxWaiterProxy {
    constructor(txWaiter, transaction) {
        this._wait = (target) => {
            const promiEvent = (0, common_1.newPromiEvent)(this._eventEmitter);
            (async () => {
                return await this._txWaiter.wait(target);
            })()
                .then(promiEvent.resolve)
                .catch(promiEvent.reject);
            return promiEvent;
        };
        /**
         * Proxy handler to call the promise or eventEmitter methods
         */
        this.proxyHandler = (target, name) => {
            if (name === "transaction") {
                return target._transaction;
            }
            if (name === "progress") {
                return Object.assign(Object.assign({}, target._txWaiter[name]), { transaction: target._transaction });
            }
            if (name === "eventEmitter") {
                return target._eventEmitter;
            }
            if (name === "wait") {
                return target._wait.bind(target);
            }
            return target._txWaiter[name];
        };
        this._txWaiter = txWaiter;
        this._transaction = transaction;
        this._eventEmitter = (0, eventEmitter_1.eventEmitter)();
        txWaiter.eventEmitter.on("progress", (progress) => {
            this._eventEmitter.emit("progress", Object.assign(Object.assign({}, progress), { transaction: this._transaction }));
        });
        return new Proxy(this, {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            get: this.proxyHandler,
        });
    }
}
exports.TxWaiterProxy = TxWaiterProxy;
/**
 * The DefaultTxWaiter is a helper for when a chain transaction has already
 * been submitted.
 */
class DefaultTxWaiter {
    /**
     * Requires a submitted chainTransaction, a chain object and the target
     * confirmation count.
     */
    constructor({ chainTransaction, chain, target, onFirstProgress, }) {
        this.updateProgress = (progress) => {
            this.progress = Object.assign(Object.assign({}, this.progress), progress);
            this.eventEmitter.emit("progress", this.progress);
            return this.progress;
        };
        /**
         * The transaction can be set at a later point. This is for situations where
         * its known that a transaction will already have been submitted, but its
         * hash isn't available yet. For example, a release transaction submitted
         * by RenVM.
         */
        this.setTransaction = (chainTransaction) => {
            return this.updateProgress({
                transaction: chainTransaction,
                status: chainTransaction && chainTransaction.txid === ""
                    ? ChainTransactionStatus.Done
                    : ChainTransactionStatus.Confirming,
            });
        };
        this.wait = (target) => {
            const promiEvent = (0, common_1.newPromiEvent)(this.eventEmitter);
            (async () => {
                const tx = this.progress.transaction;
                if (!tx) {
                    throw new Error(`Must call ".submit" first.`);
                }
                target = (0, common_1.isDefined)(target) ? target : this.progress.target;
                // If the txid is missing, then assume that the transaction
                // is confirmed. In some situations its known that a transaction
                // has taken place (e.g. by looking at the current state of the
                // chain) but there's no way of finding the transaction's details.
                // In this case, the txid will be set to "".
                if (tx.txid === "") {
                    this.updateProgress(Object.assign(Object.assign({}, this.progress), { confirmations: target, status: ChainTransactionStatus.Done }));
                    return this.progress;
                }
                let currentConfidenceRatio = -1;
                while (true) {
                    try {
                        const confidence = (await this._chain.transactionConfidence(tx)).toNumber();
                        const confidenceRatio = target === 0 ? 1 : confidence / target;
                        // The confidence has increased.
                        if (confidenceRatio > currentConfidenceRatio) {
                            if (this._onFirstProgress) {
                                await this._onFirstProgress(tx);
                                this._onFirstProgress = undefined;
                            }
                            if (confidenceRatio >= 1) {
                                // Done.
                                this.updateProgress(Object.assign(Object.assign({}, this.progress), { confirmations: confidence, status: ChainTransactionStatus.Done }));
                                break;
                            }
                            else {
                                // Update progress.
                                currentConfidenceRatio = confidenceRatio;
                                this.updateProgress(Object.assign(Object.assign({}, this.progress), { confirmations: confidence }));
                            }
                        }
                    }
                    catch (error) {
                        console.error(error);
                    }
                    await (0, sleep_1.sleep)(15 * sleep_1.sleep.SECONDS);
                }
                return this.progress;
            })()
                .then(promiEvent.resolve)
                .catch(promiEvent.reject);
            return promiEvent;
        };
        this._chain = chain;
        this._onFirstProgress = onFirstProgress;
        this.chain = chain.chain;
        this.eventEmitter = (0, eventEmitter_1.eventEmitter)();
        this.progress = Object.assign({ chain: chain.chain, status: chainTransaction && chainTransaction.txid === ""
                ? ChainTransactionStatus.Done
                : ChainTransactionStatus.Confirming, target }, (chainTransaction ? { transaction: chainTransaction } : {}));
    }
}
exports.DefaultTxWaiter = DefaultTxWaiter;
//# sourceMappingURL=txSubmitter.js.map