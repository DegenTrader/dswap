import { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PopulatedTransaction, Signer, utils } from "ethers";
import { EventFragment, FunctionFragment, Result } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { OnEvent, TypedEvent, TypedEventFilter, TypedListener } from "./common";
export interface LockGatewayV3Interface extends utils.Interface {
    functions: {
        "NAME()": FunctionFragment;
        "__GatewayStateManager_init(string,address,address)": FunctionFragment;
        "__LockGateway_init(string,address,address)": FunctionFragment;
        "getAsset()": FunctionFragment;
        "getEventNonce()": FunctionFragment;
        "getPreviousGateway()": FunctionFragment;
        "getSelectorHash()": FunctionFragment;
        "getSignatureVerifier()": FunctionFragment;
        "getToken()": FunctionFragment;
        "lock(string,string,bytes,uint256)": FunctionFragment;
        "owner()": FunctionFragment;
        "release(bytes32,uint256,bytes32,bytes)": FunctionFragment;
        "status(bytes32)": FunctionFragment;
        "token()": FunctionFragment;
        "updateAsset(string)": FunctionFragment;
        "updatePreviousGateway(address)": FunctionFragment;
        "updateSignatureVerifier(address)": FunctionFragment;
        "updateToken(address)": FunctionFragment;
    };
    encodeFunctionData(functionFragment: "NAME", values?: undefined): string;
    encodeFunctionData(functionFragment: "__GatewayStateManager_init", values: [string, string, string]): string;
    encodeFunctionData(functionFragment: "__LockGateway_init", values: [string, string, string]): string;
    encodeFunctionData(functionFragment: "getAsset", values?: undefined): string;
    encodeFunctionData(functionFragment: "getEventNonce", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPreviousGateway", values?: undefined): string;
    encodeFunctionData(functionFragment: "getSelectorHash", values?: undefined): string;
    encodeFunctionData(functionFragment: "getSignatureVerifier", values?: undefined): string;
    encodeFunctionData(functionFragment: "getToken", values?: undefined): string;
    encodeFunctionData(functionFragment: "lock", values: [string, string, BytesLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "owner", values?: undefined): string;
    encodeFunctionData(functionFragment: "release", values: [BytesLike, BigNumberish, BytesLike, BytesLike]): string;
    encodeFunctionData(functionFragment: "status", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "token", values?: undefined): string;
    encodeFunctionData(functionFragment: "updateAsset", values: [string]): string;
    encodeFunctionData(functionFragment: "updatePreviousGateway", values: [string]): string;
    encodeFunctionData(functionFragment: "updateSignatureVerifier", values: [string]): string;
    encodeFunctionData(functionFragment: "updateToken", values: [string]): string;
    decodeFunctionResult(functionFragment: "NAME", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "__GatewayStateManager_init", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "__LockGateway_init", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAsset", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getEventNonce", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPreviousGateway", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getSelectorHash", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getSignatureVerifier", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "lock", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "release", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "status", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "token", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateAsset", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updatePreviousGateway", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateSignatureVerifier", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateToken", data: BytesLike): Result;
    events: {
        "LogAssetUpdated(string,bytes32)": EventFragment;
        "LogLockToChain(string,string,bytes,uint256,uint256,string,string)": EventFragment;
        "LogPreviousGatewayUpdated(address,address)": EventFragment;
        "LogRelease(address,uint256,bytes32,bytes32)": EventFragment;
        "LogSignatureVerifierUpdated(address,address)": EventFragment;
        "LogTokenUpdated(address)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "LogAssetUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogLockToChain"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogPreviousGatewayUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogRelease"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogSignatureVerifierUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LogTokenUpdated"): EventFragment;
}
export declare type LogAssetUpdatedEvent = TypedEvent<[
    string,
    string
], {
    asset: string;
    selectorHash: string;
}>;
export declare type LogAssetUpdatedEventFilter = TypedEventFilter<LogAssetUpdatedEvent>;
export declare type LogLockToChainEvent = TypedEvent<[
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    string,
    string
], {
    recipientAddress: string;
    recipientChain: string;
    recipientPayload: string;
    amount: BigNumber;
    lockNonce: BigNumber;
    recipientAddressIndexed: string;
    recipientChainIndexed: string;
}>;
export declare type LogLockToChainEventFilter = TypedEventFilter<LogLockToChainEvent>;
export declare type LogPreviousGatewayUpdatedEvent = TypedEvent<[
    string,
    string
], {
    oldPreviousGateway: string;
    newPreviousGateway: string;
}>;
export declare type LogPreviousGatewayUpdatedEventFilter = TypedEventFilter<LogPreviousGatewayUpdatedEvent>;
export declare type LogReleaseEvent = TypedEvent<[
    string,
    BigNumber,
    string,
    string
], {
    recipient: string;
    amount: BigNumber;
    sigHash: string;
    nHash: string;
}>;
export declare type LogReleaseEventFilter = TypedEventFilter<LogReleaseEvent>;
export declare type LogSignatureVerifierUpdatedEvent = TypedEvent<[
    string,
    string
], {
    oldSignatureVerifier: string;
    newSignatureVerifier: string;
}>;
export declare type LogSignatureVerifierUpdatedEventFilter = TypedEventFilter<LogSignatureVerifierUpdatedEvent>;
export declare type LogTokenUpdatedEvent = TypedEvent<[string], {
    token: string;
}>;
export declare type LogTokenUpdatedEventFilter = TypedEventFilter<LogTokenUpdatedEvent>;
export interface LockGatewayV3 extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: LockGatewayV3Interface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        NAME(overrides?: CallOverrides): Promise<[string]>;
        __GatewayStateManager_init(asset_: string, signatureVerifier_: string, token_: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        __LockGateway_init(asset_: string, signatureVerifier_: string, token_: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        getAsset(overrides?: CallOverrides): Promise<[string]>;
        getEventNonce(overrides?: CallOverrides): Promise<[BigNumber]>;
        getPreviousGateway(overrides?: CallOverrides): Promise<[string]>;
        getSelectorHash(overrides?: CallOverrides): Promise<[string]>;
        getSignatureVerifier(overrides?: CallOverrides): Promise<[string]>;
        getToken(overrides?: CallOverrides): Promise<[string]>;
        lock(recipientAddress: string, recipientChain: string, recipientPayload: BytesLike, amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        owner(overrides?: CallOverrides): Promise<[string]>;
        release(pHash: BytesLike, amount: BigNumberish, nHash: BytesLike, sig: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        status(hash: BytesLike, overrides?: CallOverrides): Promise<[boolean]>;
        token(overrides?: CallOverrides): Promise<[string]>;
        updateAsset(nextAsset: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        updatePreviousGateway(newPreviousGateway: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        updateSignatureVerifier(newSignatureVerifier: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        updateToken(newToken: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    NAME(overrides?: CallOverrides): Promise<string>;
    __GatewayStateManager_init(asset_: string, signatureVerifier_: string, token_: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    __LockGateway_init(asset_: string, signatureVerifier_: string, token_: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    getAsset(overrides?: CallOverrides): Promise<string>;
    getEventNonce(overrides?: CallOverrides): Promise<BigNumber>;
    getPreviousGateway(overrides?: CallOverrides): Promise<string>;
    getSelectorHash(overrides?: CallOverrides): Promise<string>;
    getSignatureVerifier(overrides?: CallOverrides): Promise<string>;
    getToken(overrides?: CallOverrides): Promise<string>;
    lock(recipientAddress: string, recipientChain: string, recipientPayload: BytesLike, amount: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    owner(overrides?: CallOverrides): Promise<string>;
    release(pHash: BytesLike, amount: BigNumberish, nHash: BytesLike, sig: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    status(hash: BytesLike, overrides?: CallOverrides): Promise<boolean>;
    token(overrides?: CallOverrides): Promise<string>;
    updateAsset(nextAsset: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    updatePreviousGateway(newPreviousGateway: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    updateSignatureVerifier(newSignatureVerifier: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    updateToken(newToken: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        NAME(overrides?: CallOverrides): Promise<string>;
        __GatewayStateManager_init(asset_: string, signatureVerifier_: string, token_: string, overrides?: CallOverrides): Promise<void>;
        __LockGateway_init(asset_: string, signatureVerifier_: string, token_: string, overrides?: CallOverrides): Promise<void>;
        getAsset(overrides?: CallOverrides): Promise<string>;
        getEventNonce(overrides?: CallOverrides): Promise<BigNumber>;
        getPreviousGateway(overrides?: CallOverrides): Promise<string>;
        getSelectorHash(overrides?: CallOverrides): Promise<string>;
        getSignatureVerifier(overrides?: CallOverrides): Promise<string>;
        getToken(overrides?: CallOverrides): Promise<string>;
        lock(recipientAddress: string, recipientChain: string, recipientPayload: BytesLike, amount: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        owner(overrides?: CallOverrides): Promise<string>;
        release(pHash: BytesLike, amount: BigNumberish, nHash: BytesLike, sig: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        status(hash: BytesLike, overrides?: CallOverrides): Promise<boolean>;
        token(overrides?: CallOverrides): Promise<string>;
        updateAsset(nextAsset: string, overrides?: CallOverrides): Promise<void>;
        updatePreviousGateway(newPreviousGateway: string, overrides?: CallOverrides): Promise<void>;
        updateSignatureVerifier(newSignatureVerifier: string, overrides?: CallOverrides): Promise<void>;
        updateToken(newToken: string, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "LogAssetUpdated(string,bytes32)"(asset?: null, selectorHash?: BytesLike | null): LogAssetUpdatedEventFilter;
        LogAssetUpdated(asset?: null, selectorHash?: BytesLike | null): LogAssetUpdatedEventFilter;
        "LogLockToChain(string,string,bytes,uint256,uint256,string,string)"(recipientAddress?: null, recipientChain?: null, recipientPayload?: null, amount?: null, lockNonce?: BigNumberish | null, recipientAddressIndexed?: string | null, recipientChainIndexed?: string | null): LogLockToChainEventFilter;
        LogLockToChain(recipientAddress?: null, recipientChain?: null, recipientPayload?: null, amount?: null, lockNonce?: BigNumberish | null, recipientAddressIndexed?: string | null, recipientChainIndexed?: string | null): LogLockToChainEventFilter;
        "LogPreviousGatewayUpdated(address,address)"(oldPreviousGateway?: string | null, newPreviousGateway?: string | null): LogPreviousGatewayUpdatedEventFilter;
        LogPreviousGatewayUpdated(oldPreviousGateway?: string | null, newPreviousGateway?: string | null): LogPreviousGatewayUpdatedEventFilter;
        "LogRelease(address,uint256,bytes32,bytes32)"(recipient?: string | null, amount?: null, sigHash?: BytesLike | null, nHash?: BytesLike | null): LogReleaseEventFilter;
        LogRelease(recipient?: string | null, amount?: null, sigHash?: BytesLike | null, nHash?: BytesLike | null): LogReleaseEventFilter;
        "LogSignatureVerifierUpdated(address,address)"(oldSignatureVerifier?: string | null, newSignatureVerifier?: string | null): LogSignatureVerifierUpdatedEventFilter;
        LogSignatureVerifierUpdated(oldSignatureVerifier?: string | null, newSignatureVerifier?: string | null): LogSignatureVerifierUpdatedEventFilter;
        "LogTokenUpdated(address)"(token?: string | null): LogTokenUpdatedEventFilter;
        LogTokenUpdated(token?: string | null): LogTokenUpdatedEventFilter;
    };
    estimateGas: {
        NAME(overrides?: CallOverrides): Promise<BigNumber>;
        __GatewayStateManager_init(asset_: string, signatureVerifier_: string, token_: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        __LockGateway_init(asset_: string, signatureVerifier_: string, token_: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        getAsset(overrides?: CallOverrides): Promise<BigNumber>;
        getEventNonce(overrides?: CallOverrides): Promise<BigNumber>;
        getPreviousGateway(overrides?: CallOverrides): Promise<BigNumber>;
        getSelectorHash(overrides?: CallOverrides): Promise<BigNumber>;
        getSignatureVerifier(overrides?: CallOverrides): Promise<BigNumber>;
        getToken(overrides?: CallOverrides): Promise<BigNumber>;
        lock(recipientAddress: string, recipientChain: string, recipientPayload: BytesLike, amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        owner(overrides?: CallOverrides): Promise<BigNumber>;
        release(pHash: BytesLike, amount: BigNumberish, nHash: BytesLike, sig: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        status(hash: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        token(overrides?: CallOverrides): Promise<BigNumber>;
        updateAsset(nextAsset: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        updatePreviousGateway(newPreviousGateway: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        updateSignatureVerifier(newSignatureVerifier: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        updateToken(newToken: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        NAME(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        __GatewayStateManager_init(asset_: string, signatureVerifier_: string, token_: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        __LockGateway_init(asset_: string, signatureVerifier_: string, token_: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        getAsset(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getEventNonce(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPreviousGateway(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getSelectorHash(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getSignatureVerifier(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        lock(recipientAddress: string, recipientChain: string, recipientPayload: BytesLike, amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        release(pHash: BytesLike, amount: BigNumberish, nHash: BytesLike, sig: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        status(hash: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        token(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        updateAsset(nextAsset: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        updatePreviousGateway(newPreviousGateway: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        updateSignatureVerifier(newSignatureVerifier: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        updateToken(newToken: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}
//# sourceMappingURL=LockGatewayV3.d.ts.map