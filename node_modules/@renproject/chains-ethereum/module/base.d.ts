import { Provider } from "@ethersproject/providers";
import { ChainTransaction, ContractChain, InputChainTransaction, InputType, OutputType, RenNetwork, TxSubmitter, TxWaiter } from "@renproject/utils";
import BigNumber from "bignumber.js";
import { ethers } from "ethers";
import { EthArg } from "./utils/abi";
import { EVMTxSubmitter } from "./utils/evmTxSubmitter";
import { EVMPayloadInterface } from "./utils/payloads/evmParams";
import { EthereumClassConfig, EthProvider, EthSigner, EVMExplorer, EVMNetworkConfig, EVMNetworkInput } from "./utils/types";
export declare class EthereumBaseChain implements ContractChain<EVMPayloadInterface, EVMPayloadInterface> {
    static chain: string;
    chain: string;
    assets: {
        [asset: string]: string;
    };
    static configMap: {
        [network in RenNetwork]?: EVMNetworkConfig;
    };
    configMap: {
        [network in RenNetwork]?: EVMNetworkConfig;
    };
    provider: Provider;
    signer?: EthSigner;
    network: EVMNetworkConfig;
    explorer: EVMExplorer;
    private _logger;
    private _config;
    constructor({ network, provider, signer, config, }: {
        network: EVMNetworkInput;
        provider: EthProvider;
        signer?: EthSigner;
        config?: EthereumClassConfig;
    });
    getMintAsset: (asset: string) => Promise<string>;
    getRenAsset: (asset: string) => Promise<string>;
    getMintGateway: (asset: string) => Promise<string>;
    getLockAsset: (asset: string) => Promise<string>;
    getLockGateway: (asset: string) => Promise<string>;
    validateAddress: (address: string) => boolean;
    validateTransaction: (transaction: Partial<ChainTransaction> & ({
        txid: string;
    } | {
        txHash: string;
    })) => boolean;
    addressExplorerLink: (address: string) => string;
    addressToBytes: (address: string) => Uint8Array;
    addressFromBytes: (bytes: Uint8Array) => string;
    txHashToBytes: (txHash: string) => Uint8Array;
    txHashFromBytes: (bytes: Uint8Array) => string;
    transactionExplorerLink: ({ txid, txHash, }: Partial<ChainTransaction> & ({
        txid: string;
    } | {
        txHash: string;
    })) => string | undefined;
    withProvider: (web3Provider: EthProvider) => this;
    withSigner: (signer: EthSigner) => this;
    checkProviderNetwork: (provider?: Provider) => Promise<{
        result: boolean;
        actualNetworkId: number;
        expectedNetworkId: number;
        expectedNetworkLabel: string;
    }>;
    checkProviderNetworkCached: (provider?: Provider | undefined) => Promise<{
        result: boolean;
        actualNetworkId: number;
        expectedNetworkId: number;
        expectedNetworkLabel: string;
    }>;
    checkSignerNetwork: () => Promise<{
        result: boolean;
        actualNetworkId: number;
        expectedNetworkId: number;
        expectedNetworkLabel: string;
    }>;
    switchSignerNetwork: () => Promise<void>;
    getOutputPayload: (asset: string, inputType: InputType, outputType: OutputType, contractCall: EVMPayloadInterface) => Promise<{
        to: string;
        toBytes: Uint8Array;
        payload: Uint8Array;
    } | undefined>;
    /** Return true if the asset originates from the chain. */
    isLockAsset: (assetSymbol: string) => Promise<boolean>;
    isDepositAsset: (assetSymbol: string) => boolean;
    /**
     * `assetIsSupported` should return true if the asset is native to the
     * MintChain.
     *
     * ```ts
     * ethereum.assetIsSupported = asset => asset === "ETH";
     * ```
     */
    isMintAsset: (asset: string) => Promise<boolean>;
    /**
     * `assetDecimals` should return the number of decimals of the asset.
     *
     * If the asset is not supported, an error should be thrown.
     *
     */
    assetDecimals: (asset: string) => Promise<number>;
    transactionConfidence: (transaction: ChainTransaction) => Promise<BigNumber>;
    getBalance: (asset: string, address?: string) => Promise<BigNumber>;
    getOutputTx: (inputType: InputType, outputType: OutputType, asset: string, contractCall: EVMPayloadInterface, getParams: () => {
        pHash: Uint8Array;
        nHash: Uint8Array;
        amount?: BigNumber;
        sigHash?: Uint8Array;
        signature?: Uint8Array;
    }, confirmationTarget: number) => Promise<TxSubmitter | TxWaiter>;
    /**
     * Read a burn reference from an Ethereum transaction - or submit a
     * transaction first if the transaction details have been provided.
     */
    getInputTx: (inputType: InputType, outputType: OutputType, asset: string, contractCall: EVMPayloadInterface, getParams: () => {
        toChain: string;
        toPayload: {
            to: string;
            payload: Uint8Array;
        } | undefined;
        gatewayAddress?: string;
    }, confirmationTarget: number, onInput: (input: InputChainTransaction) => void) => Promise<TxSubmitter | TxWaiter>;
    getInSetup: (asset: string, inputType: InputType, outputType: OutputType, contractCall: EVMPayloadInterface, getParams: () => {
        toChain: string;
        toPayload: {
            to: string;
            toBytes: Uint8Array;
            payload: Uint8Array;
        } | undefined;
        gatewayAddress?: string;
    }) => Promise<{
        [key: string]: TxWaiter<import("@renproject/utils").ChainTransactionProgress> | EVMTxSubmitter;
    }>;
    getOutSetup: (asset: string, inputType: InputType, outputType: OutputType, contractCall: EVMPayloadInterface, getParams: () => {
        pHash: Uint8Array;
        nHash: Uint8Array;
        amount?: BigNumber;
        sigHash?: Uint8Array;
        signature?: Uint8Array;
    }) => Promise<{
        [key: string]: TxWaiter<import("@renproject/utils").ChainTransactionProgress> | EVMTxSubmitter;
    }>;
    private getPayloadHandler;
    createGatewayAddress: (_asset: string, fromPayload: EVMPayloadInterface, shardPublicKey: Uint8Array, gHash: Uint8Array) => Promise<string> | string;
    private getEVMParams;
    Account: ({ account, amount, convertUnit, anyoneCanSubmit, infiniteApproval, payloadConfig, }?: {
        account?: string | undefined;
        amount?: string | number | BigNumber | undefined;
        convertUnit?: boolean | undefined;
        anyoneCanSubmit?: boolean | undefined;
        infiniteApproval?: boolean | undefined;
        payloadConfig?: EVMPayloadInterface["payloadConfig"];
    }) => EVMPayloadInterface;
    Address: (address: string, payloadConfig?: EVMPayloadInterface["payloadConfig"]) => EVMPayloadInterface;
    Contract: (params: {
        to: string;
        method: string;
        params: EthArg[];
        withRenParams: boolean;
        txConfig?: ethers.PayableOverrides | undefined;
        payloadConfig?: EVMPayloadInterface["payloadConfig"];
    }) => EVMPayloadInterface;
    /**
     * Import an existing Ethereum transaction.
     *
     * @example
     * ethereum.Transaction({
     *   txHash: "0xf7dbf98bcebd7b803917e00e7e3292843a4b7bf66016638811cea4705a32d73e",
     * })
     */
    Transaction: (partialTx: Partial<ChainTransaction> & ({
        txid: string;
    } | {
        txHash: string;
    }), payloadConfig?: EVMPayloadInterface["payloadConfig"]) => EVMPayloadInterface;
}
//# sourceMappingURL=base.d.ts.map