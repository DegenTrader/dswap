import { JsonFragmentType } from "@ethersproject/abi";
import { Provider } from "@ethersproject/providers";
import { ChainTransaction, InputChainTransaction, InputType, RenNetwork } from "@renproject/utils";
import { ethers } from "ethers";
import { TypedEvent } from "../contracts/typechain/common";
import { LogLockToChainEvent } from "../contracts/typechain/LockGatewayV3";
import { LogBurnEvent, LogBurnToChainEvent } from "../contracts/typechain/MintGatewayV3";
import { LogTransferredEvent } from "../contracts/typechain/TransferWithLog";
import { AbiItem } from "./abi";
import { EVMNetworkConfig, EVMNetworkInput } from "./types";
/**
 * Convert an Ethereum transaction hash from its standard format to the format
 * required by RenVM.
 *
 * @param txHash An Ethereum transaction hash formatted as a 0x-prefixed
 * hex string.
 * @returns The same Ethereum transaction hash formatted as bytes.
 */
export declare const txHashToBytes: (txHash: string) => Uint8Array;
/**
 * Convert an Ethereum transaction hash from the format required by RenVM to its
 * standard format.
 *
 * @param bytes An Ethereum transaction hash formatted as bytes.
 * @returns The same Ethereum transaction hash formatted as a 0x-prefixed hex
 * string.
 */
export declare const txHashFromBytes: (bytes: Uint8Array) => string;
/**
 * Convert an EVM txHash to a RenVM ChainTransaction struct.
 * The txindex for Ethereum is currently set to 0, and the nonce is used instead
 * to differentiate locks/burns in the same EVM transaction.
 */
export declare const txHashToChainTransaction: (chain: string, txHash: string, explorerLink: string) => ChainTransaction;
export declare const mapBurnLogToInputChainTransaction: (chain: string, asset: string, event: LogBurnEvent, explorerLink: string) => InputChainTransaction;
export declare const mapBurnToChainLogToInputChainTransaction: (chain: string, asset: string, event: LogBurnToChainEvent, explorerLink: string) => InputChainTransaction;
export declare const mapLockLogToInputChainTransaction: (chain: string, asset: string, event: LogLockToChainEvent, explorerLink: string) => InputChainTransaction;
export declare const mapTransferLogToInputChainTransaction: (chain: string, asset: string, event: LogTransferredEvent, explorerLink: string) => InputChainTransaction;
/** Find an input transaction (i.e. a burn or a lock) by its nonce. */
export declare const findInputByNonce: (chain: string, inputType: InputType, network: EVMNetworkConfig, provider: Provider, asset: string, nonce: Uint8Array, transactionExplorerLink: (params: Partial<ChainTransaction> & ({
    txid: string;
} | {
    txHash: string;
})) => string | undefined, blockLimit?: number) => Promise<InputChainTransaction | undefined>;
export declare const findMintBySigHash: (network: EVMNetworkConfig, provider: Provider, asset: string, nHash: Uint8Array, sigHash: Uint8Array | undefined, blockLimit?: number) => Promise<string | undefined>;
export declare const findReleaseBySigHash: (network: EVMNetworkConfig, provider: Provider, asset: string, nHash: Uint8Array, sigHash: Uint8Array | undefined, blockLimit?: number) => Promise<string | undefined>;
export declare const filterLogs: <T extends TypedEvent<any, any>>(logs: ethers.providers.Log[], eventABI: AbiItem) => {
    event: T;
    log: ethers.providers.Log;
}[];
export declare const validateAddress: (address: string) => boolean;
export declare const validateTransaction: (transaction: Partial<ChainTransaction> & ({
    txid: string;
} | {
    txHash: string;
})) => boolean;
export declare const rawEncode: (types: Array<string | JsonFragmentType>, parameters: unknown[]) => Uint8Array;
export declare const isEVMNetworkConfig: (renNetwork: EVMNetworkInput) => renNetwork is EVMNetworkConfig;
export declare const resolveEVMNetworkConfig: (configMap: {
    mainnet?: EVMNetworkConfig | undefined;
    testnet?: EVMNetworkConfig | undefined;
    devnet?: EVMNetworkConfig | undefined;
}, renNetwork: EVMNetworkInput) => EVMNetworkConfig;
/**
 * Resolve an EVM chain's JSON-RPC endpoints, replacing variable keys such as
 * `${INFURA_API_KEY}` with the value provided in `variables`. If a URL has a
 * variable key that isn't provided, it is removed from the final list.
 * If a variable's value is undefined, it is not replaced.
 *
 * @param urls An array of JSON-RPC urls.
 * @param variables An object mapping variable keys to their values.
 * @param protocol A RegExp matching the required url protocol. Defaults to "https"
 * @returns An array of JSON-RPC urls with variables resolved to their values.
 *
 * @example
 * resolveRpcEndpoints(
 *  ["https://test.com/${TEST}", "https://test2.com/${MISSING}", "wss://test3.com"],
 *  { TEST: "test"},
 * )
 * > ["https://test.com/test"]
 */
export declare const resolveRpcEndpoints: (urls: string[], variables?: ({
    INFURA_API_KEY?: string | undefined;
    ALCHEMY_API_KEY?: string | undefined;
} & {
    [variableKey: string]: string | undefined;
}) | undefined, protocol?: RegExp | string) => string[];
/**
 *
 * @param provider An ethers.js provider.
 * @param network The config of the EVM network that the signer should be
 * connected to.
 * @returns The result of the comparison, including details of the expected and
 * actual networks. If `result` is true, then the signer's network is correct.
 */
export declare const checkProviderNetwork: (provider: Provider, network: EVMNetworkConfig) => Promise<{
    result: boolean;
    actualNetworkId: number;
    expectedNetworkId: number;
    expectedNetworkLabel: string;
}>;
//# sourceMappingURL=generic.d.ts.map