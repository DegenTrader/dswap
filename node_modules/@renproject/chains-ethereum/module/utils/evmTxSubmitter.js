var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { ChainTransactionStatus, ErrorWithCode, eventEmitter, RenJSError, utils, } from "@renproject/utils";
import { Contract, ethers, } from "ethers";
import { Logger } from "ethers/lib/utils";
import { checkProviderNetwork, txHashToChainTransaction } from "./generic";
/** Fix numeric values in the transaction config. */
export const fixEVMTransactionConfig = (...txConfigs) => {
    let result = {};
    for (const txConfig of txConfigs) {
        result = Object.assign(Object.assign({}, result), txConfig);
        if (utils.isDefined(result.value)) {
            result.value = result.value.toString();
        }
        if (utils.isDefined(result.gasPrice)) {
            result.gasPrice = result.gasPrice.toString();
        }
    }
    return result;
};
/**
 * Call a method on an EVM contract from the provided signer.
 *
 * @param signer An Ethers signer to make the call from.
 * @param to The EVM contract's address.
 * @param abi The ABI of the method being called.
 * @param params The parameters for the method, as defined by the ABI.
 * @param txConfig Optional EVM transaction config.
 * @returns An unconfirmed transaction response.
 */
export const callContract = (signer, to, abi, params, txConfig) => __awaiter(void 0, void 0, void 0, function* () {
    if (!abi.name) {
        throw new Error(`ABI must include method name.`);
    }
    const contract = new Contract(to, [abi], signer);
    return yield contract[abi.name](...params, fixEVMTransactionConfig(txConfig));
});
/**
 * EVMTxSubmitter handles submitting and waiting for EVM transactions.
 */
export class EVMTxSubmitter {
    constructor({ network, getProvider, getSigner, chain, payload, target, getPayloadHandler, getParams, onReceipt, findExistingTransaction, transactionExplorerLink, }) {
        this.updateProgress = (progress) => {
            this.progress = Object.assign(Object.assign({}, this.progress), progress);
            this.eventEmitter.emit("progress", this.progress);
            return this.progress;
        };
        this.export = (options = {}) => __awaiter(this, void 0, void 0, function* () {
            if (!this._payload.type) {
                throw new Error(`No ${this.chain} payload provided.`);
            }
            return yield this._getPayloadHandler(this._payload.type).export({
                network: this._network,
                signer: this._getSigner(),
                payload: this._payload,
                evmParams: this._getParams(),
                overrides: options,
                getPayloadHandler: this._getPayloadHandler,
            });
        });
        this.submit = (options = {}) => {
            const promiEvent = utils.newPromiEvent(this.eventEmitter);
            (() => __awaiter(this, void 0, void 0, function* () {
                if (!this._payload.type) {
                    throw new Error(`No ${this.chain} payload provided.`);
                }
                const provider = this._getProvider();
                if (this._findExistingTransaction && provider) {
                    const existingTransaction = yield this._findExistingTransaction();
                    if (existingTransaction) {
                        if (existingTransaction.txHash === "") {
                            this.updateProgress({
                                status: ChainTransactionStatus.Done,
                                confirmations: this.progress.target,
                            });
                            return this.progress;
                        }
                        this._tx = yield provider.getTransaction(String(existingTransaction.txHash));
                    }
                }
                if (!this._tx) {
                    const signer = this._getSigner();
                    if (!signer) {
                        throw new Error(`Must connect ${this.chain} signer.`);
                    }
                    if (!signer.provider) {
                        throw new Error("EVM signer has no connected provider.");
                    }
                    const payloadHandler = this._getPayloadHandler(this._payload.type);
                    if (payloadHandler.required) {
                        const required = yield payloadHandler.required({
                            network: this._network,
                            signer: signer,
                            payload: this._payload,
                            evmParams: this._getParams(),
                            getPayloadHandler: this._getPayloadHandler,
                        });
                        if (!required) {
                            this.updateProgress({
                                status: ChainTransactionStatus.Done,
                                confirmations: this.progress.target,
                            });
                        }
                    }
                    // TODO: Check if `signer.sendTransaction` will always work
                    // with `from` defined.
                    const _a = yield payloadHandler.export({
                        network: this._network,
                        signer: signer,
                        payload: this._payload,
                        evmParams: this._getParams(),
                        overrides: options,
                        getPayloadHandler: this._getPayloadHandler,
                    }), { from } = _a, tx = __rest(_a, ["from"]);
                    if (from) {
                        const recipient = ethers.utils.getAddress(from);
                        const address = ethers.utils.getAddress(yield signer.getAddress());
                        if (recipient !== address) {
                            throw new Error(`Transaction can only be submitted by ${recipient} - connected address is ${address}.`);
                        }
                    }
                    // Check the signer's network.
                    const providerNetworkCheck = yield checkProviderNetwork(signer.provider || provider, this._network);
                    if (!providerNetworkCheck.result) {
                        throw new ErrorWithCode(`Invalid ${this.chain} signer network: expected ${providerNetworkCheck.expectedNetworkId} (${providerNetworkCheck.expectedNetworkLabel}), got ${providerNetworkCheck.actualNetworkId}.`, RenJSError.INCORRECT_PROVIDER_NETWORK);
                    }
                    // `populateTransaction` fills in the missing details - e.g.
                    // gas details. It's commented out because it seems that it's
                    // better to calculate this in the `sendTransaction` step.
                    // const populatedTx = await signer.populateTransaction(tx);
                    this._tx = yield signer.sendTransaction(tx);
                }
                this.updateProgress({
                    status: this._tx.confirmations < this.progress.target
                        ? ChainTransactionStatus.Confirming
                        : ChainTransactionStatus.Done,
                    transaction: txHashToChainTransaction(this.chain, this._tx.hash, (this._transactionExplorerLink &&
                        this._transactionExplorerLink({
                            txHash: this._tx.hash,
                        })) ||
                        ""),
                    confirmations: this._tx.confirmations,
                });
                return this.progress;
            }))()
                .then(promiEvent.resolve)
                .catch(promiEvent.reject);
            return promiEvent;
        };
        this.setTransaction = (chainTransaction) => __awaiter(this, void 0, void 0, function* () {
            const provider = this._getProvider();
            this._tx = yield provider.getTransaction(String(chainTransaction.txHash));
            return this.updateProgress({
                status: this._tx.confirmations < this.progress.target
                    ? ChainTransactionStatus.Confirming
                    : ChainTransactionStatus.Done,
                transaction: txHashToChainTransaction(this.chain, this._tx.hash, (this._transactionExplorerLink &&
                    this._transactionExplorerLink({
                        txHash: this._tx.hash,
                    })) ||
                    ""),
                confirmations: this._tx.confirmations,
            });
        });
        this.wait = (target) => {
            const promiEvent = utils.newPromiEvent(this.eventEmitter);
            (() => __awaiter(this, void 0, void 0, function* () {
                if (this.progress.status === ChainTransactionStatus.Ready) {
                    throw new Error(`Must call ".submit" first.`);
                }
                target = utils.isDefined(target) ? target : this.progress.target;
                // Wait for each confirmation until the target is reached.
                while (this._tx &&
                    (this._tx.confirmations < target || this._onReceipt)) {
                    try {
                        const receipt = yield this._tx.wait(Math.min(this._tx.confirmations + 1, target));
                        if (this._onReceipt) {
                            const onReceipt = this._onReceipt;
                            this._onReceipt = undefined;
                            onReceipt(receipt);
                        }
                        const existingConfirmations = this._tx.confirmations;
                        this._tx.confirmations = receipt.confirmations;
                        if (receipt.confirmations > existingConfirmations) {
                            this.updateProgress(Object.assign(Object.assign({}, this.progress), { status: this._tx.confirmations < this.progress.target
                                    ? ChainTransactionStatus.Confirming
                                    : ChainTransactionStatus.Done, transaction: txHashToChainTransaction(this.chain, this._tx.hash, (this._transactionExplorerLink &&
                                    this._transactionExplorerLink({
                                        txHash: this._tx.hash,
                                    })) ||
                                    ""), confirmations: this._tx.confirmations }));
                        }
                    }
                    catch (error) {
                        if (ErrorWithCode.isErrorWithCode(error)) {
                            if (error.code === Logger.errors.TRANSACTION_REPLACED) {
                                // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion,@typescript-eslint/no-explicit-any
                                const replacement = error
                                    .replacement;
                                const previousTx = this._tx;
                                this._tx = replacement;
                                this.updateProgress({
                                    status: ChainTransactionStatus.Confirming,
                                    transaction: txHashToChainTransaction(this.chain, replacement.hash, (this._transactionExplorerLink &&
                                        this._transactionExplorerLink({
                                            txHash: replacement.hash,
                                        })) ||
                                        ""),
                                    target: target,
                                    confirmations: replacement.confirmations,
                                    replaced: txHashToChainTransaction(this.chain, previousTx.hash, (this._transactionExplorerLink &&
                                        this._transactionExplorerLink({
                                            txHash: previousTx.hash,
                                        })) ||
                                        ""),
                                });
                                continue;
                            }
                            else if (error.code === Logger.errors.CALL_EXCEPTION) {
                                this.updateProgress({
                                    status: ChainTransactionStatus.Reverted,
                                    transaction: txHashToChainTransaction(this.chain, this._tx.hash, (this._transactionExplorerLink &&
                                        this._transactionExplorerLink({
                                            txHash: this._tx.hash,
                                        })) ||
                                        ""),
                                    target: target,
                                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion,@typescript-eslint/no-explicit-any
                                    confirmations: error.receipt
                                        .confirmations,
                                    revertReason: error.message,
                                });
                                throw error;
                            }
                        }
                        console.error(error);
                        continue;
                    }
                }
                if (this.progress.status !== ChainTransactionStatus.Done &&
                    this._tx &&
                    this._tx.confirmations >= this.progress.target) {
                    this.updateProgress({
                        status: ChainTransactionStatus.Done,
                    });
                }
                return this.progress;
            }))()
                .then(promiEvent.resolve)
                .catch(promiEvent.reject);
            return promiEvent;
        };
        this._network = network;
        this._getProvider = getProvider;
        this._getSigner = getSigner;
        this.chain = chain;
        this._payload = payload;
        this._getPayloadHandler = getPayloadHandler;
        this._getParams = getParams;
        this._onReceipt = onReceipt;
        this._findExistingTransaction = findExistingTransaction;
        this._transactionExplorerLink = transactionExplorerLink;
        this.eventEmitter = eventEmitter();
        this.progress = {
            chain,
            status: ChainTransactionStatus.Ready,
            confirmations: 0,
            target: target,
        };
    }
}
//# sourceMappingURL=evmTxSubmitter.js.map