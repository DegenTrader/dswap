var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { ErrorWithCode, RenJSError, utils } from "@renproject/utils";
import { Contract, } from "ethers";
import { payloadToABI } from "../abi";
import { fixEVMTransactionConfig } from "../evmTxSubmitter";
import { rawEncode } from "../generic";
import { replaceRenParam, } from "./evmParams";
// Replace contract address and parameter values with Ren parameters.
const resolveEVMContractParams = (payload, evmParams) => __awaiter(void 0, void 0, void 0, function* () {
    return Object.assign(Object.assign({}, payload), { params: Object.assign(Object.assign({}, payload.params), { to: yield replaceRenParam(payload.params.to, evmParams), params: yield Promise.all(payload.params.params.map((value) => __awaiter(void 0, void 0, void 0, function* () {
                return (Object.assign(Object.assign({}, value), { value: yield replaceRenParam(value.value, evmParams) }));
            }))) }) });
});
export const contractPayloadHandler = {
    getSetup: ({ payload }) => payload.setup || {},
    getPayload: ({ network, payload, evmParams, }) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            payload = yield resolveEVMContractParams(payload, evmParams);
        }
        catch (error) {
            throw ErrorWithCode.updateError(error, RenJSError.PARAMETER_ERROR, `Error getting contract-call payload`);
        }
        const args = payload.params.params.filter((arg) => !arg.notInPayload);
        for (const arg of args) {
            if (arg.value === undefined) {
                if (arg.renParam) {
                    throw new ErrorWithCode(`Payload parameter '${arg.name}' is undefined. (Did you accidentally set 'withRenParams' for a burn?)`, RenJSError.PARAMETER_ERROR);
                }
                throw new ErrorWithCode(`Payload parameter '${arg.name}' is undefined.`, RenJSError.PARAMETER_ERROR);
            }
        }
        if (payload.params.to === undefined) {
            throw new ErrorWithCode(`Payload 'to' is undefined.`, RenJSError.PARAMETER_ERROR);
        }
        const types = args.map((_a) => {
            var { value: _ } = _a, params = __rest(_a, ["value"]);
            return params;
        });
        const values = args.map((param) => param.value);
        let p;
        try {
            p = rawEncode(types, values);
        }
        catch (error) {
            throw new ErrorWithCode(error, RenJSError.PARAMETER_ERROR, `Error encoding ${network.selector} parameters`);
        }
        return {
            to: payload.params.to,
            toBytes: utils.fromHex(payload.params.to),
            payload: p,
        };
    }),
    export: ({ network, signer, payload, evmParams, overrides, }) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            payload = yield resolveEVMContractParams(payload, evmParams);
        }
        catch (error) {
            throw ErrorWithCode.updateError(error, RenJSError.PARAMETER_ERROR, `Error resolving parameters for contract-call`);
        }
        // Get parameter values, checking first if each value has been
        // overridden.
        const params = payload.params.params.map((x) => overrides.overrides && utils.isDefined(overrides.overrides[x.name])
            ? Object.assign(Object.assign({}, x), { value: overrides.overrides[x.name] }) : x);
        const paramTypes = params.map((_a) => {
            var { value: _value } = _a, paramABI = __rest(_a, ["value"]);
            return paramABI;
        });
        const paramValues = params.map((x) => x.value);
        for (const param of params) {
            if (param.value === undefined) {
                throw ErrorWithCode.updateError(new Error(`Parameter '${param.name}' is undefined.`), RenJSError.PARAMETER_ERROR);
            }
        }
        try {
            rawEncode(paramTypes, paramValues);
        }
        catch (error) {
            throw new ErrorWithCode(error, RenJSError.PARAMETER_ERROR, `Error encoding ${network.selector} parameters`);
        }
        const abi = payloadToABI(payload.params.method, params)[0];
        if (!abi.name) {
            throw new Error(`ABI must include method name.`);
        }
        const contract = new Contract(payload.params.to.toLowerCase(), [abi], signer);
        return yield contract.populateTransaction[abi.name](...paramValues, fixEVMTransactionConfig(payload.txConfig, payload.params.txConfig, overrides.txConfig));
    }),
};
//# sourceMappingURL=evmContractPayload.js.map