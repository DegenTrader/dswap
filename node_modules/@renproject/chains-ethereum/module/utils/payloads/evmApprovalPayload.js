var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { utils } from "@renproject/utils";
import BigNumber from "bignumber.js";
import { getERC20Instance } from "../../contracts";
import { contractPayloadHandler, } from "./evmContractPayload";
import { EVMParam, replaceRenParam, } from "./evmParams";
const resolveEVMApprovalParams = (payload, evmParams) => __awaiter(void 0, void 0, void 0, function* () {
    return Object.assign(Object.assign({}, payload), { params: Object.assign(Object.assign({}, payload.params), { token: yield replaceRenParam(payload.params.token, evmParams), spender: yield replaceRenParam(payload.params.spender, evmParams), amount: yield replaceRenParam(payload.params.amount, evmParams) }) });
});
const getContractFromApproval = (network, payload, evmParams) => __awaiter(void 0, void 0, void 0, function* () {
    const amount = utils.isDefined(payload.params.amount)
        ? new BigNumber(payload.params.amount)
            .shiftedBy(payload.params.convertUnit
            ? yield evmParams[EVMParam.EVM_TOKEN_DECIMALS]()
            : 0)
            .toFixed()
        : undefined;
    return {
        chain: network.selector,
        type: "contract",
        params: {
            to: payload.params.token,
            method: "approve",
            params: [
                {
                    type: "address",
                    name: "to",
                    value: payload.params.spender,
                },
                {
                    type: "uint256",
                    name: "amount",
                    value: amount,
                },
            ],
        },
    };
});
export const approvalPayloadHandler = {
    getSetup: ({ payload }) => payload.setup || {},
    required: ({ signer, payload, evmParams, }) => __awaiter(void 0, void 0, void 0, function* () {
        payload = yield resolveEVMApprovalParams(payload, evmParams);
        const token = payload.params.token;
        if (!signer) {
            return true;
        }
        const erc20Instance = getERC20Instance(signer, token);
        const account = yield signer.getAddress();
        const allowance = new BigNumber((yield erc20Instance.allowance(account, payload.params.spender)).toString());
        const amount = new BigNumber(payload.params.amount).shiftedBy(payload.params.convertUnit
            ? yield evmParams[EVMParam.EVM_TOKEN_DECIMALS]()
            : 0);
        return allowance.lt(amount);
    }),
    export: ({ network, signer, payload, evmParams, overrides, getPayloadHandler, }) => __awaiter(void 0, void 0, void 0, function* () {
        payload = yield resolveEVMApprovalParams(payload, evmParams);
        return contractPayloadHandler.export({
            network,
            signer,
            payload: yield getContractFromApproval(network, payload, evmParams),
            evmParams,
            overrides,
            getPayloadHandler,
        });
    }),
};
//# sourceMappingURL=evmApprovalPayload.js.map