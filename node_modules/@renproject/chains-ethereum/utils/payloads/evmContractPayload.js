"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.contractPayloadHandler = void 0;
const utils_1 = require("@renproject/utils");
const ethers_1 = require("ethers");
const abi_1 = require("../abi");
const evmTxSubmitter_1 = require("../evmTxSubmitter");
const generic_1 = require("../generic");
const evmParams_1 = require("./evmParams");
// Replace contract address and parameter values with Ren parameters.
const resolveEVMContractParams = async (payload, evmParams) => {
    return Object.assign(Object.assign({}, payload), { params: Object.assign(Object.assign({}, payload.params), { to: await (0, evmParams_1.replaceRenParam)(payload.params.to, evmParams), params: await Promise.all(payload.params.params.map(async (value) => (Object.assign(Object.assign({}, value), { value: await (0, evmParams_1.replaceRenParam)(value.value, evmParams) })))) }) });
};
exports.contractPayloadHandler = {
    getSetup: ({ payload }) => payload.setup || {},
    getPayload: async ({ network, payload, evmParams, }) => {
        try {
            payload = await resolveEVMContractParams(payload, evmParams);
        }
        catch (error) {
            throw utils_1.ErrorWithCode.updateError(error, utils_1.RenJSError.PARAMETER_ERROR, `Error getting contract-call payload`);
        }
        const args = payload.params.params.filter((arg) => !arg.notInPayload);
        for (const arg of args) {
            if (arg.value === undefined) {
                if (arg.renParam) {
                    throw new utils_1.ErrorWithCode(`Payload parameter '${arg.name}' is undefined. (Did you accidentally set 'withRenParams' for a burn?)`, utils_1.RenJSError.PARAMETER_ERROR);
                }
                throw new utils_1.ErrorWithCode(`Payload parameter '${arg.name}' is undefined.`, utils_1.RenJSError.PARAMETER_ERROR);
            }
        }
        if (payload.params.to === undefined) {
            throw new utils_1.ErrorWithCode(`Payload 'to' is undefined.`, utils_1.RenJSError.PARAMETER_ERROR);
        }
        const types = args.map((_a) => {
            var { value: _ } = _a, params = __rest(_a, ["value"]);
            return params;
        });
        const values = args.map((param) => param.value);
        let p;
        try {
            p = (0, generic_1.rawEncode)(types, values);
        }
        catch (error) {
            throw new utils_1.ErrorWithCode(error, utils_1.RenJSError.PARAMETER_ERROR, `Error encoding ${network.selector} parameters`);
        }
        return {
            to: payload.params.to,
            toBytes: utils_1.utils.fromHex(payload.params.to),
            payload: p,
        };
    },
    export: async ({ network, signer, payload, evmParams, overrides, }) => {
        try {
            payload = await resolveEVMContractParams(payload, evmParams);
        }
        catch (error) {
            throw utils_1.ErrorWithCode.updateError(error, utils_1.RenJSError.PARAMETER_ERROR, `Error resolving parameters for contract-call`);
        }
        // Get parameter values, checking first if each value has been
        // overridden.
        const params = payload.params.params.map((x) => overrides.overrides && utils_1.utils.isDefined(overrides.overrides[x.name])
            ? Object.assign(Object.assign({}, x), { value: overrides.overrides[x.name] }) : x);
        const paramTypes = params.map((_a) => {
            var { value: _value } = _a, paramABI = __rest(_a, ["value"]);
            return paramABI;
        });
        const paramValues = params.map((x) => x.value);
        for (const param of params) {
            if (param.value === undefined) {
                throw utils_1.ErrorWithCode.updateError(new Error(`Parameter '${param.name}' is undefined.`), utils_1.RenJSError.PARAMETER_ERROR);
            }
        }
        try {
            (0, generic_1.rawEncode)(paramTypes, paramValues);
        }
        catch (error) {
            throw new utils_1.ErrorWithCode(error, utils_1.RenJSError.PARAMETER_ERROR, `Error encoding ${network.selector} parameters`);
        }
        const abi = (0, abi_1.payloadToABI)(payload.params.method, params)[0];
        if (!abi.name) {
            throw new Error(`ABI must include method name.`);
        }
        const contract = new ethers_1.Contract(payload.params.to.toLowerCase(), [abi], signer);
        return await contract.populateTransaction[abi.name](...paramValues, (0, evmTxSubmitter_1.fixEVMTransactionConfig)(payload.txConfig, payload.params.txConfig, overrides.txConfig));
    },
};
//# sourceMappingURL=evmContractPayload.js.map