"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.accountPayloadHandler = void 0;
const utils_1 = require("@renproject/utils");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const ethers_1 = require("ethers");
const evmApprovalPayload_1 = require("./evmApprovalPayload");
const evmContractPayload_1 = require("./evmContractPayload");
const evmParams_1 = require("./evmParams");
exports.accountPayloadHandler = {
    getSetup: async ({ network, signer, payload, evmParams, getPayloadHandler, }) => {
        if (!evmContractPayload_1.contractPayloadHandler.getSetup) {
            throw new Error(`Missing contract payload handler.`);
        }
        const contractPayload = await getContractFromAccount(network, payload, evmParams);
        if (!contractPayload) {
            return {};
        }
        const amount = payload.params.infiniteApproval
            ? new bignumber_js_1.default(2).pow(256).minus(1).toFixed()
            : utils_1.utils.isDefined(payload.params.amount)
                ? new bignumber_js_1.default(payload.params.amount)
                    .shiftedBy(payload.params.convertUnit
                    ? await evmParams[evmParams_1.EVMParam.EVM_TOKEN_DECIMALS]()
                    : 0)
                    .toFixed()
                : undefined;
        if (!amount) {
            return {};
        }
        if (!evmParams[evmParams_1.EVMParam.EVM_GATEWAY_IS_DEPOSIT_ASSET]) {
            const approval = {
                chain: network.selector,
                type: "approval",
                params: {
                    token: evmParams_1.EVMParam.EVM_TOKEN_ADDRESS,
                    spender: evmParams_1.EVMParam.EVM_GATEWAY,
                    amount,
                },
            };
            if (evmApprovalPayload_1.approvalPayloadHandler.required &&
                (await evmApprovalPayload_1.approvalPayloadHandler.required({
                    network,
                    signer,
                    payload: approval,
                    evmParams,
                    getPayloadHandler,
                }))) {
                return { approval };
            }
        }
        return {};
    },
    getPayload: async ({ network, signer, payload, evmParams, getPayloadHandler, }) => {
        if (!evmContractPayload_1.contractPayloadHandler.getPayload) {
            throw new Error(`Missing contract payload handler.`);
        }
        const contractPayload = await getContractFromAccount(network, payload, evmParams);
        if (!contractPayload) {
            const to = await (0, evmParams_1.replaceRenParam)(payload.params.address, evmParams);
            return {
                to,
                toBytes: utils_1.utils.fromHex(to),
                payload: new Uint8Array(),
            };
        }
        let p = await evmContractPayload_1.contractPayloadHandler.getPayload({
            network,
            signer,
            payload: contractPayload,
            evmParams,
            getPayloadHandler,
        });
        if (p.to.toLowerCase() ===
            (await evmParams[evmParams_1.EVMParam.EVM_GATEWAY]()).toLowerCase()) {
            const to = await (0, evmParams_1.replaceRenParam)(payload.params.address, evmParams);
            if (!to) {
                throw new utils_1.ErrorWithCode(payload.params.address === evmParams_1.EVMParam.EVM_ACCOUNT
                    ? ` Must connect ${network.selector} signer.`
                    : `Empty ${network.selector} recipient.`, utils_1.RenJSError.PARAMETER_ERROR);
            }
            p = Object.assign(Object.assign({}, p), { to, toBytes: utils_1.utils.fromHex(to) });
        }
        return p;
    },
    export: async ({ network, signer, payload, evmParams, overrides, getPayloadHandler, }) => {
        const contractPayload = await getContractFromAccount(network, payload, evmParams);
        if (!contractPayload) {
            throw new Error(`Unable to submit empty payload for release to ${payload.params.address}.`);
        }
        const exported = await evmContractPayload_1.contractPayloadHandler.export({
            network,
            signer,
            payload: contractPayload,
            evmParams,
            overrides,
            getPayloadHandler,
        });
        if (!payload.params.anyoneCanSubmit) {
            return Object.assign(Object.assign({}, exported), { from: ethers_1.ethers.utils.getAddress(await (0, evmParams_1.replaceRenParam)(payload.params.address, evmParams)) });
        }
        return exported;
    },
};
const gatewayMintParams = [
    {
        type: "bytes32",
        name: "pHash",
        value: evmParams_1.EVMParam.EVM_PHASH,
        notInPayload: true,
        renParam: true,
    },
    {
        type: "uint256",
        name: "amount",
        value: evmParams_1.EVMParam.EVM_AMOUNT,
        notInPayload: true,
        renParam: true,
    },
    {
        type: "bytes32",
        name: "nHash",
        value: evmParams_1.EVMParam.EVM_NHASH,
        notInPayload: true,
        renParam: true,
    },
    {
        type: "bytes",
        name: "sig",
        value: evmParams_1.EVMParam.EVM_SIGNATURE,
        notInPayload: true,
        renParam: true,
    },
];
const basicBridgeParams = (address) => [
    {
        type: "string",
        name: "symbol",
        value: evmParams_1.EVMParam.EVM_ASSET,
    },
    {
        type: "address",
        name: "recipient",
        value: address,
    },
    {
        type: "uint256",
        name: "amount",
        value: evmParams_1.EVMParam.EVM_AMOUNT,
        notInPayload: true,
        renParam: true,
    },
    {
        type: "bytes32",
        name: "nHash",
        value: evmParams_1.EVMParam.EVM_NHASH,
        notInPayload: true,
        renParam: true,
    },
    {
        type: "bytes",
        name: "sig",
        value: evmParams_1.EVMParam.EVM_SIGNATURE,
        notInPayload: true,
        renParam: true,
    },
];
const gatewayBurnToParams = (toPayload, amount) => [
    {
        name: "recipientAddress",
        type: "string",
        value: evmParams_1.EVMParam.EVM_TO_ADDRESS,
    },
    {
        name: "recipientChain",
        type: "string",
        value: evmParams_1.EVMParam.EVM_TO_CHAIN,
    },
    {
        name: "recipientPayload",
        type: "bytes",
        value: toPayload,
    },
    {
        name: "amount",
        type: "uint256",
        value: amount,
    },
];
const gatewayBurnParams = (amount) => [
    {
        type: "bytes",
        name: "to",
        value: evmParams_1.EVMParam.EVM_TO_ADDRESS_BYTES,
    },
    {
        type: "uint256",
        name: "amount",
        value: amount,
    },
];
const transferWithLogParams = [
    {
        type: "address",
        name: "to",
        value: evmParams_1.EVMParam.EVM_GATEWAY_DEPOSIT_ADDRESS,
    },
];
/**
 * Generate an EVM Contract payload from the account payload details.
 */
const getContractFromAccount = async (network, payload, evmParams) => {
    const amount = utils_1.utils.isDefined(payload.params.amount)
        ? new bignumber_js_1.default(payload.params.amount)
            .shiftedBy(payload.params.convertUnit
            ? await evmParams[evmParams_1.EVMParam.EVM_TOKEN_DECIMALS]()
            : 0)
            .toFixed()
        : undefined;
    switch (evmParams[evmParams_1.EVMParam.EVM_TRANSACTION_TYPE]) {
        case utils_1.InputType.Lock:
            if (!amount) {
                throw utils_1.ErrorWithCode.updateError(new Error(`Must provide amount to account payload`), utils_1.RenJSError.PARAMETER_ERROR);
            }
            if (evmParams[evmParams_1.EVMParam.EVM_GATEWAY_IS_DEPOSIT_ASSET]) {
                return {
                    chain: network.selector,
                    type: "contract",
                    params: {
                        to: evmParams_1.EVMParam.EVM_TRANSFER_WITH_LOG_CONTRACT,
                        method: "transferWithLog",
                        params: transferWithLogParams,
                        txConfig: {
                            value: amount,
                        },
                    },
                };
            }
            return {
                chain: network.selector,
                type: "contract",
                params: {
                    to: evmParams_1.EVMParam.EVM_GATEWAY,
                    method: "lock",
                    params: gatewayBurnToParams(evmParams_1.EVMParam.EVM_TO_PAYLOAD, amount),
                },
            };
        case utils_1.InputType.Burn:
            if (!amount) {
                throw utils_1.ErrorWithCode.updateError(new Error(`Must provide amount to account payload`), utils_1.RenJSError.PARAMETER_ERROR);
            }
            const toPayload = evmParams[evmParams_1.EVMParam.EVM_TO_PAYLOAD] || new Uint8Array();
            if (evmParams[evmParams_1.EVMParam.EVM_OUTPUT_TYPE] === "mint" ||
                toPayload.length > 0) {
                return {
                    chain: network.selector,
                    type: "contract",
                    params: {
                        to: evmParams_1.EVMParam.EVM_GATEWAY,
                        method: "burnWithPayload",
                        params: gatewayBurnToParams(toPayload, amount),
                    },
                };
            }
            else {
                return {
                    chain: network.selector,
                    type: "contract",
                    params: {
                        to: evmParams_1.EVMParam.EVM_GATEWAY,
                        method: "burn",
                        params: gatewayBurnParams(amount),
                    },
                };
            }
        case utils_1.OutputType.Mint:
            if (payload.params.anyoneCanSubmit) {
                return {
                    chain: network.selector,
                    type: "contract",
                    params: {
                        to: network.addresses.BasicBridge,
                        method: "mint",
                        params: basicBridgeParams(payload.params.address),
                    },
                };
            }
            return {
                chain: network.selector,
                type: "contract",
                params: {
                    to: evmParams_1.EVMParam.EVM_GATEWAY,
                    method: "mint",
                    params: gatewayMintParams,
                },
            };
        case utils_1.OutputType.Release:
            if (evmParams[evmParams_1.EVMParam.EVM_GATEWAY_IS_DEPOSIT_ASSET]) {
                return undefined;
            }
            if (payload.params.anyoneCanSubmit) {
                return {
                    chain: network.selector,
                    type: "contract",
                    params: {
                        to: network.addresses.BasicBridge,
                        method: "release",
                        params: basicBridgeParams(payload.params.address),
                    },
                };
            }
            return {
                chain: network.selector,
                type: "contract",
                params: {
                    to: evmParams_1.EVMParam.EVM_GATEWAY,
                    method: "release",
                    params: gatewayMintParams,
                },
            };
        default:
            throw new Error(`Unable to use account payload for set-up call.`);
    }
};
//# sourceMappingURL=evmAddressPayload.js.map