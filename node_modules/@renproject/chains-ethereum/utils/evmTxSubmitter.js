"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EVMTxSubmitter = exports.callContract = exports.fixEVMTransactionConfig = void 0;
const utils_1 = require("@renproject/utils");
const ethers_1 = require("ethers");
const utils_2 = require("ethers/lib/utils");
const generic_1 = require("./generic");
/** Fix numeric values in the transaction config. */
const fixEVMTransactionConfig = (...txConfigs) => {
    let result = {};
    for (const txConfig of txConfigs) {
        result = Object.assign(Object.assign({}, result), txConfig);
        if (utils_1.utils.isDefined(result.value)) {
            result.value = result.value.toString();
        }
        if (utils_1.utils.isDefined(result.gasPrice)) {
            result.gasPrice = result.gasPrice.toString();
        }
    }
    return result;
};
exports.fixEVMTransactionConfig = fixEVMTransactionConfig;
/**
 * Call a method on an EVM contract from the provided signer.
 *
 * @param signer An Ethers signer to make the call from.
 * @param to The EVM contract's address.
 * @param abi The ABI of the method being called.
 * @param params The parameters for the method, as defined by the ABI.
 * @param txConfig Optional EVM transaction config.
 * @returns An unconfirmed transaction response.
 */
const callContract = async (signer, to, abi, params, txConfig) => {
    if (!abi.name) {
        throw new Error(`ABI must include method name.`);
    }
    const contract = new ethers_1.Contract(to, [abi], signer);
    return await contract[abi.name](...params, (0, exports.fixEVMTransactionConfig)(txConfig));
};
exports.callContract = callContract;
/**
 * EVMTxSubmitter handles submitting and waiting for EVM transactions.
 */
class EVMTxSubmitter {
    constructor({ network, getProvider, getSigner, chain, payload, target, getPayloadHandler, getParams, onReceipt, findExistingTransaction, transactionExplorerLink, }) {
        this.updateProgress = (progress) => {
            this.progress = Object.assign(Object.assign({}, this.progress), progress);
            this.eventEmitter.emit("progress", this.progress);
            return this.progress;
        };
        this.export = async (options = {}) => {
            if (!this._payload.type) {
                throw new Error(`No ${this.chain} payload provided.`);
            }
            return await this._getPayloadHandler(this._payload.type).export({
                network: this._network,
                signer: this._getSigner(),
                payload: this._payload,
                evmParams: this._getParams(),
                overrides: options,
                getPayloadHandler: this._getPayloadHandler,
            });
        };
        this.submit = (options = {}) => {
            const promiEvent = utils_1.utils.newPromiEvent(this.eventEmitter);
            (async () => {
                if (!this._payload.type) {
                    throw new Error(`No ${this.chain} payload provided.`);
                }
                const provider = this._getProvider();
                if (this._findExistingTransaction && provider) {
                    const existingTransaction = await this._findExistingTransaction();
                    if (existingTransaction) {
                        if (existingTransaction.txHash === "") {
                            this.updateProgress({
                                status: utils_1.ChainTransactionStatus.Done,
                                confirmations: this.progress.target,
                            });
                            return this.progress;
                        }
                        this._tx = await provider.getTransaction(String(existingTransaction.txHash));
                    }
                }
                if (!this._tx) {
                    const signer = this._getSigner();
                    if (!signer) {
                        throw new Error(`Must connect ${this.chain} signer.`);
                    }
                    if (!signer.provider) {
                        throw new Error("EVM signer has no connected provider.");
                    }
                    const payloadHandler = this._getPayloadHandler(this._payload.type);
                    if (payloadHandler.required) {
                        const required = await payloadHandler.required({
                            network: this._network,
                            signer: signer,
                            payload: this._payload,
                            evmParams: this._getParams(),
                            getPayloadHandler: this._getPayloadHandler,
                        });
                        if (!required) {
                            this.updateProgress({
                                status: utils_1.ChainTransactionStatus.Done,
                                confirmations: this.progress.target,
                            });
                        }
                    }
                    // TODO: Check if `signer.sendTransaction` will always work
                    // with `from` defined.
                    const _a = await payloadHandler.export({
                        network: this._network,
                        signer: signer,
                        payload: this._payload,
                        evmParams: this._getParams(),
                        overrides: options,
                        getPayloadHandler: this._getPayloadHandler,
                    }), { from } = _a, tx = __rest(_a, ["from"]);
                    if (from) {
                        const recipient = ethers_1.ethers.utils.getAddress(from);
                        const address = ethers_1.ethers.utils.getAddress(await signer.getAddress());
                        if (recipient !== address) {
                            throw new Error(`Transaction can only be submitted by ${recipient} - connected address is ${address}.`);
                        }
                    }
                    // Check the signer's network.
                    const providerNetworkCheck = await (0, generic_1.checkProviderNetwork)(signer.provider || provider, this._network);
                    if (!providerNetworkCheck.result) {
                        throw new utils_1.ErrorWithCode(`Invalid ${this.chain} signer network: expected ${providerNetworkCheck.expectedNetworkId} (${providerNetworkCheck.expectedNetworkLabel}), got ${providerNetworkCheck.actualNetworkId}.`, utils_1.RenJSError.INCORRECT_PROVIDER_NETWORK);
                    }
                    // `populateTransaction` fills in the missing details - e.g.
                    // gas details. It's commented out because it seems that it's
                    // better to calculate this in the `sendTransaction` step.
                    // const populatedTx = await signer.populateTransaction(tx);
                    this._tx = await signer.sendTransaction(tx);
                }
                this.updateProgress({
                    status: this._tx.confirmations < this.progress.target
                        ? utils_1.ChainTransactionStatus.Confirming
                        : utils_1.ChainTransactionStatus.Done,
                    transaction: (0, generic_1.txHashToChainTransaction)(this.chain, this._tx.hash, (this._transactionExplorerLink &&
                        this._transactionExplorerLink({
                            txHash: this._tx.hash,
                        })) ||
                        ""),
                    confirmations: this._tx.confirmations,
                });
                return this.progress;
            })()
                .then(promiEvent.resolve)
                .catch(promiEvent.reject);
            return promiEvent;
        };
        this.setTransaction = async (chainTransaction) => {
            const provider = this._getProvider();
            this._tx = await provider.getTransaction(String(chainTransaction.txHash));
            return this.updateProgress({
                status: this._tx.confirmations < this.progress.target
                    ? utils_1.ChainTransactionStatus.Confirming
                    : utils_1.ChainTransactionStatus.Done,
                transaction: (0, generic_1.txHashToChainTransaction)(this.chain, this._tx.hash, (this._transactionExplorerLink &&
                    this._transactionExplorerLink({
                        txHash: this._tx.hash,
                    })) ||
                    ""),
                confirmations: this._tx.confirmations,
            });
        };
        this.wait = (target) => {
            const promiEvent = utils_1.utils.newPromiEvent(this.eventEmitter);
            (async () => {
                if (this.progress.status === utils_1.ChainTransactionStatus.Ready) {
                    throw new Error(`Must call ".submit" first.`);
                }
                target = utils_1.utils.isDefined(target) ? target : this.progress.target;
                // Wait for each confirmation until the target is reached.
                while (this._tx &&
                    (this._tx.confirmations < target || this._onReceipt)) {
                    try {
                        const receipt = await this._tx.wait(Math.min(this._tx.confirmations + 1, target));
                        if (this._onReceipt) {
                            const onReceipt = this._onReceipt;
                            this._onReceipt = undefined;
                            onReceipt(receipt);
                        }
                        const existingConfirmations = this._tx.confirmations;
                        this._tx.confirmations = receipt.confirmations;
                        if (receipt.confirmations > existingConfirmations) {
                            this.updateProgress(Object.assign(Object.assign({}, this.progress), { status: this._tx.confirmations < this.progress.target
                                    ? utils_1.ChainTransactionStatus.Confirming
                                    : utils_1.ChainTransactionStatus.Done, transaction: (0, generic_1.txHashToChainTransaction)(this.chain, this._tx.hash, (this._transactionExplorerLink &&
                                    this._transactionExplorerLink({
                                        txHash: this._tx.hash,
                                    })) ||
                                    ""), confirmations: this._tx.confirmations }));
                        }
                    }
                    catch (error) {
                        if (utils_1.ErrorWithCode.isErrorWithCode(error)) {
                            if (error.code === utils_2.Logger.errors.TRANSACTION_REPLACED) {
                                // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion,@typescript-eslint/no-explicit-any
                                const replacement = error
                                    .replacement;
                                const previousTx = this._tx;
                                this._tx = replacement;
                                this.updateProgress({
                                    status: utils_1.ChainTransactionStatus.Confirming,
                                    transaction: (0, generic_1.txHashToChainTransaction)(this.chain, replacement.hash, (this._transactionExplorerLink &&
                                        this._transactionExplorerLink({
                                            txHash: replacement.hash,
                                        })) ||
                                        ""),
                                    target: target,
                                    confirmations: replacement.confirmations,
                                    replaced: (0, generic_1.txHashToChainTransaction)(this.chain, previousTx.hash, (this._transactionExplorerLink &&
                                        this._transactionExplorerLink({
                                            txHash: previousTx.hash,
                                        })) ||
                                        ""),
                                });
                                continue;
                            }
                            else if (error.code === utils_2.Logger.errors.CALL_EXCEPTION) {
                                this.updateProgress({
                                    status: utils_1.ChainTransactionStatus.Reverted,
                                    transaction: (0, generic_1.txHashToChainTransaction)(this.chain, this._tx.hash, (this._transactionExplorerLink &&
                                        this._transactionExplorerLink({
                                            txHash: this._tx.hash,
                                        })) ||
                                        ""),
                                    target: target,
                                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion,@typescript-eslint/no-explicit-any
                                    confirmations: error.receipt
                                        .confirmations,
                                    revertReason: error.message,
                                });
                                throw error;
                            }
                        }
                        console.error(error);
                        continue;
                    }
                }
                if (this.progress.status !== utils_1.ChainTransactionStatus.Done &&
                    this._tx &&
                    this._tx.confirmations >= this.progress.target) {
                    this.updateProgress({
                        status: utils_1.ChainTransactionStatus.Done,
                    });
                }
                return this.progress;
            })()
                .then(promiEvent.resolve)
                .catch(promiEvent.reject);
            return promiEvent;
        };
        this._network = network;
        this._getProvider = getProvider;
        this._getSigner = getSigner;
        this.chain = chain;
        this._payload = payload;
        this._getPayloadHandler = getPayloadHandler;
        this._getParams = getParams;
        this._onReceipt = onReceipt;
        this._findExistingTransaction = findExistingTransaction;
        this._transactionExplorerLink = transactionExplorerLink;
        this.eventEmitter = (0, utils_1.eventEmitter)();
        this.progress = {
            chain,
            status: utils_1.ChainTransactionStatus.Ready,
            confirmations: 0,
            target: target,
        };
    }
}
exports.EVMTxSubmitter = EVMTxSubmitter;
//# sourceMappingURL=evmTxSubmitter.js.map