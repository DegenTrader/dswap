"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkProviderNetwork = exports.resolveRpcEndpoints = exports.resolveEVMNetworkConfig = exports.isEVMNetworkConfig = exports.rawEncode = exports.validateTransaction = exports.validateAddress = exports.filterLogs = exports.findReleaseBySigHash = exports.findMintBySigHash = exports.findInputByNonce = exports.mapTransferLogToInputChainTransaction = exports.mapLockLogToInputChainTransaction = exports.mapBurnToChainLogToInputChainTransaction = exports.mapBurnLogToInputChainTransaction = exports.txHashToChainTransaction = exports.txHashFromBytes = exports.txHashToBytes = void 0;
const abi_1 = require("@ethersproject/abi");
const utils_1 = require("@renproject/utils");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const ethers_1 = require("ethers");
const utils_2 = require("ethers/lib/utils");
const contracts_1 = require("../contracts");
const gatewayRegistry_1 = require("./gatewayRegistry");
/**
 * Convert an Ethereum transaction hash from its standard format to the format
 * required by RenVM.
 *
 * @param txHash An Ethereum transaction hash formatted as a 0x-prefixed
 * hex string.
 * @returns The same Ethereum transaction hash formatted as bytes.
 */
const txHashToBytes = (txHash) => {
    return utils_1.utils.fromHex(txHash);
};
exports.txHashToBytes = txHashToBytes;
/**
 * Convert an Ethereum transaction hash from the format required by RenVM to its
 * standard format.
 *
 * @param bytes An Ethereum transaction hash formatted as bytes.
 * @returns The same Ethereum transaction hash formatted as a 0x-prefixed hex
 * string.
 */
const txHashFromBytes = (bytes) => {
    return utils_1.utils.Ox(bytes);
};
exports.txHashFromBytes = txHashFromBytes;
/**
 * Convert an EVM txHash to a RenVM ChainTransaction struct.
 * The txindex for Ethereum is currently set to 0, and the nonce is used instead
 * to differentiate locks/burns in the same EVM transaction.
 */
const txHashToChainTransaction = (chain, txHash, explorerLink) => {
    const txHashBytes = utils_1.utils.fromHex(txHash);
    return {
        chain,
        txHash: txHash === "" ? txHash : utils_1.utils.Ox(txHashBytes),
        txid: utils_1.utils.toURLBase64(txHashBytes),
        txindex: "0",
        explorerLink,
    };
};
exports.txHashToChainTransaction = txHashToChainTransaction;
const mapBurnLogToInputChainTransaction = (chain, asset, event, explorerLink) => {
    const [to, amount, burnNonce] = event.args;
    return Object.assign(Object.assign({}, (0, exports.txHashToChainTransaction)(chain, event.transactionHash, explorerLink)), { asset, amount: amount.toString(), toRecipient: utils_1.utils.toUTF8String(utils_1.utils.fromHex(to)), nonce: utils_1.utils.toURLBase64(utils_1.utils.toNBytes(burnNonce.toString(), 32)) });
};
exports.mapBurnLogToInputChainTransaction = mapBurnLogToInputChainTransaction;
const mapBurnToChainLogToInputChainTransaction = (chain, asset, event, explorerLink) => {
    const [recipientAddress, recipientChain, recipientPayload, amount, burnNonce,] = event.args;
    return Object.assign(Object.assign({}, (0, exports.txHashToChainTransaction)(chain, event.transactionHash, explorerLink)), { asset, amount: amount.toString(), toRecipient: recipientAddress, toChain: recipientChain, toPayload: utils_1.utils.toURLBase64(utils_1.utils.fromHex(recipientPayload)), nonce: utils_1.utils.toURLBase64(utils_1.utils.toNBytes(burnNonce.toString(), 32)) });
};
exports.mapBurnToChainLogToInputChainTransaction = mapBurnToChainLogToInputChainTransaction;
const mapLockLogToInputChainTransaction = (chain, asset, event, explorerLink) => {
    const [recipientAddress, recipientChain, recipientPayload, amount, lockNonce,] = event.args;
    const nonceBytes = utils_1.utils.toNBytes(new bignumber_js_1.default(lockNonce.toString()), 32);
    if (nonceBytes.length !== 32) {
        throw new Error("Invalid nonce length");
    }
    return Object.assign(Object.assign({}, (0, exports.txHashToChainTransaction)(chain, event.transactionHash, explorerLink)), { asset, amount: amount.toString(), toRecipient: recipientAddress, toChain: recipientChain, toPayload: utils_1.utils.toURLBase64(utils_1.utils.fromHex(recipientPayload)), nonce: utils_1.utils.toURLBase64(nonceBytes) });
};
exports.mapLockLogToInputChainTransaction = mapLockLogToInputChainTransaction;
const mapTransferLogToInputChainTransaction = (chain, asset, event, explorerLink) => {
    const [_from, _to, amount] = event.args;
    return Object.assign(Object.assign({}, (0, exports.txHashToChainTransaction)(chain, event.transactionHash, explorerLink)), { asset, amount: amount.toString() });
};
exports.mapTransferLogToInputChainTransaction = mapTransferLogToInputChainTransaction;
/** Find an input transaction (i.e. a burn or a lock) by its nonce. */
const findInputByNonce = async (chain, inputType, network, provider, asset, nonce, transactionExplorerLink, blockLimit) => {
    if (inputType === utils_1.InputType.Burn) {
        const gatewayAddress = await (0, gatewayRegistry_1.getMintGateway)(network, provider, asset);
        const logBurnABI = (0, contracts_1.findABIMethod)(contracts_1.MintGatewayABI, "LogBurn");
        const burnLogs = await getPastLogs(provider, gatewayAddress, logBurnABI, [utils_1.utils.Ox(nonce)], blockLimit);
        if (burnLogs.length) {
            return (0, exports.mapBurnLogToInputChainTransaction)(chain, asset, burnLogs[0], transactionExplorerLink({
                txHash: burnLogs[0].transactionHash,
            }) || "");
        }
        const logBurnToChainABI = (0, contracts_1.findABIMethod)(contracts_1.MintGatewayABI, "LogBurnToChain");
        const burnToChainLogs = await getPastLogs(provider, gatewayAddress, logBurnToChainABI, [utils_1.utils.Ox(nonce)], blockLimit);
        if (burnToChainLogs.length) {
            return (0, exports.mapBurnToChainLogToInputChainTransaction)(chain, asset, burnToChainLogs[0], transactionExplorerLink({
                txHash: burnToChainLogs[0].transactionHash,
            }) || "");
        }
    }
    else {
        const gatewayAddress = await (0, gatewayRegistry_1.getLockGateway)(network, provider, asset);
        const logLockABI = (0, contracts_1.findABIMethod)(contracts_1.LockGatewayABI, "LogLockToChain");
        const logLockLogs = await getPastLogs(provider, gatewayAddress, logLockABI, [utils_1.utils.Ox(nonce)], blockLimit);
        if (logLockLogs.length) {
            return (0, exports.mapLockLogToInputChainTransaction)(chain, asset, logLockLogs[0], transactionExplorerLink({
                txHash: logLockLogs[0].transactionHash,
            }) || "");
        }
    }
    return undefined;
};
exports.findInputByNonce = findInputByNonce;
const findMintBySigHash = async (network, provider, asset, nHash, sigHash, blockLimit) => {
    const gatewayAddress = await (0, gatewayRegistry_1.getMintGateway)(network, provider, asset);
    const gatewayInstance = (0, contracts_1.getMintGatewayInstance)(provider, gatewayAddress);
    const logMintABI = (0, contracts_1.findABIMethod)(contracts_1.MintGatewayABI, "LogMint");
    // Attempt to look up the mint's event log by its nHash, allowing for the
    // mint's transaction hash to be returned.
    try {
        const mintEvents = await getPastLogs(provider, gatewayAddress, logMintABI, [null, null, utils_1.utils.Ox(nHash)], blockLimit);
        if (mintEvents.length) {
            if (mintEvents.length > 1) {
                console.warn(`Found more than one mint log.`);
            }
            return mintEvents[0].transactionHash;
        }
    }
    catch (error) {
        // If there's no sigHash, the status function call can't be called as a
        // fallback so the error is thrown.
        if (!sigHash) {
            throw error;
        }
        else {
            console.error(error);
        }
    }
    if (sigHash) {
        // Check the status in case the mint's event may be too old to be
        // fetched. If the status is true, the mint succeeded, but no hash
        // is available - `""` is returned instead.
        const status = await gatewayInstance.status(utils_1.utils.Ox(sigHash));
        if (status) {
            return "";
        }
    }
    return undefined;
};
exports.findMintBySigHash = findMintBySigHash;
const findReleaseBySigHash = async (network, provider, asset, nHash, sigHash, blockLimit) => {
    const gatewayAddress = await (0, gatewayRegistry_1.getLockGateway)(network, provider, asset);
    const gatewayInstance = (0, contracts_1.getLockGatewayInstance)(provider, gatewayAddress);
    const logLockABI = (0, contracts_1.findABIMethod)(contracts_1.LockGatewayABI, "LogRelease");
    // Attempt to look up the releases's event log by its nHash, allowing for
    // the releases's transaction hash to be returned.
    try {
        const newReleaseEvents = await getPastLogs(provider, gatewayAddress, logLockABI, [null, null, utils_1.utils.Ox(nHash)], blockLimit);
        if (newReleaseEvents.length) {
            if (newReleaseEvents.length > 1) {
                console.warn(`Found more than one release log.`);
            }
            return newReleaseEvents[0].transactionHash;
        }
    }
    catch (error) {
        // If there's no sigHash, the status function call can't be called as a
        // fallback so the error is thrown.
        if (!sigHash) {
            throw error;
        }
        else {
            console.error(error);
        }
    }
    if (sigHash) {
        // Check the status in case the mint's event may be too old to be
        // fetched. If the status is true, the mint succeeded, but no hash
        // is available - `""` is returned instead.
        const status = await gatewayInstance.status(utils_1.utils.Ox(sigHash));
        if (status) {
            return "";
        }
    }
    return undefined;
};
exports.findReleaseBySigHash = findReleaseBySigHash;
const filterLogs = (logs, eventABI) => {
    if (!logs) {
        throw Error("No events found in transaction");
    }
    const logTopic = utils_1.utils.Ox((0, contracts_1.getEventTopic)(eventABI));
    const logDecoder = new ethers_1.ethers.utils.Interface([eventABI]);
    return logs
        .filter((log) => log.topics[0] === logTopic)
        .map((log) => ({
        event: Object.assign(Object.assign({}, logDecoder.parseLog(log)), { 
            // address: event.address,
            transactionHash: log.transactionHash }),
        log,
    }));
};
exports.filterLogs = filterLogs;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const getPastLogs = async (provider, contractAddress, eventABI, filter, blockLimit) => {
    let fromBlock = 1;
    let toBlock = "latest";
    if (blockLimit) {
        toBlock = new bignumber_js_1.default((await provider.getBlockNumber()).toString()).toNumber();
        fromBlock = toBlock - blockLimit + 1;
    }
    const events = await provider.getLogs({
        address: contractAddress,
        fromBlock: fromBlock,
        toBlock: toBlock,
        topics: [utils_1.utils.Ox((0, contracts_1.getEventTopic)(eventABI)), ...filter],
    });
    return (0, exports.filterLogs)(events, eventABI).map((e) => e.event);
};
// /**
//  * Waits for the receipt of a transaction to be available, retrying every 15
//  * seconds until it is.
//  *
//  * @param web3 A web3 instance.
//  * @param txHash The hash of the transaction being read.
//  */
// export const waitForReceipt = async (
//     provider: Provider,
//     txHash: string,
//     logger?: Logger,
//     timeout?: number,
// ): Promise<TransactionReceipt> =>
//     // eslint-disable-next-line @typescript-eslint/no-misused-promises
//     new Promise<TransactionReceipt>(async (resolve, reject) => {
//         assertType<string>("string", { txHash });
//         // Wait for confirmation
//         let receipt: TransactionReceipt | undefined;
//         while (!receipt || !receipt.blockHash) {
//             if (logger) {
//                 logger.debug(`Fetching transaction receipt: ${txHash}`);
//             }
//             receipt = await provider.getTransactionReceipt(txHash);
//             if (receipt && receipt.blockHash) {
//                 break;
//             }
//             await sleep(isDefined(timeout) ? timeout : 15 * SECONDS);
//         }
//         // Status might be undefined - so check against `false` explicitly.
//         if (receipt.status === 0) {
//             reject(
//                 new Error(
//                     `Transaction was reverted. { "transactionHash": "${txHash}" }`,
//                 ),
//             );
//             return;
//         }
//         resolve(receipt);
//         return;
//     });
// export const submitToEthereum = async (
//     chain: string,
//     signer: Signer,
//     to: string,
//     abi: AbiItem,
//     txConfig: PayableOverrides,
//     params: unknown[],
//     eventEmitter: EventEmitterTyped<{
//         transaction: [ChainTransaction];
//         confirmation: [number, { status: number }];
//     }>,
// ): Promise<ContractReceipt> => {
//     if (!abi.name) {
//         throw new Error(`ABI must include method name.`);
//     }
//     const contract = new Contract(to, [abi], signer);
//     const config: PayableOverrides = {
//         ...txConfig,
//         ...{
//             value:
//                 txConfig && txConfig.value
//                     ? txConfig.value.toString()
//                     : undefined,
//             gasPrice:
//                 txConfig && txConfig.gasPrice
//                     ? txConfig.gasPrice.toString()
//                     : undefined,
//         },
//     };
//     const tx: ContractTransaction = await contract[abi.name](...params, config);
//     eventEmitter.emit("transaction", txHashToChainTransaction(chain, tx.hash));
//     const receipt = await tx.wait();
//     eventEmitter.emit("confirmation", 1, { status: 1 });
//     return receipt;
// };
const validateAddress = (address) => {
    if (/^.+\.eth$/.exec(address)) {
        return true;
    }
    try {
        ethers_1.ethers.utils.getAddress(address);
        return true;
    }
    catch (_error) {
        return false;
    }
};
exports.validateAddress = validateAddress;
const validateTransaction = (transaction) => {
    return ((utils_1.utils.isDefined(transaction.txid) ||
        utils_1.utils.isDefined(transaction.txHash)) &&
        (transaction.txHash
            ? utils_1.utils.isHex(transaction.txHash, {
                length: 32,
                prefix: true,
            })
            : true) &&
        (transaction.txid
            ? utils_1.utils.isURLBase64(transaction.txid, {
                length: 32,
            })
            : true) &&
        (transaction.txindex
            ? !new bignumber_js_1.default(transaction.txindex).isNaN()
            : true) &&
        (transaction.txHash && transaction.txid
            ? utils_1.utils.toURLBase64((0, exports.txHashToBytes)(transaction.txHash)) ===
                transaction.txid
            : true) &&
        (transaction.txindex === undefined || transaction.txindex === "0"));
};
exports.validateTransaction = validateTransaction;
const tupleRegEx = /^tuple\((.*)\)$/;
const rawEncode = (types, parameters) => {
    return utils_1.utils.fromHex(utils_2.defaultAbiCoder.encode(types.map((type) => {
        // If a tuple has no components, set them.
        if (typeof type === "object" && !type.components) {
            const match = tupleRegEx.exec(type.type || "");
            if (match) {
                type = Object.assign(Object.assign({}, type), { components: match[1].split(",").map((value) => ({
                        type: value,
                    })) });
            }
        }
        return abi_1.ParamType.from(type);
    }), parameters));
};
exports.rawEncode = rawEncode;
const isEVMNetworkConfig = (renNetwork) => !!renNetwork.addresses;
exports.isEVMNetworkConfig = isEVMNetworkConfig;
const resolveEVMNetworkConfig = (configMap, renNetwork) => {
    if (!renNetwork) {
        const defaultNetwork = configMap[utils_1.RenNetwork.Mainnet] ||
            configMap[utils_1.RenNetwork.Testnet] ||
            configMap[utils_1.RenNetwork.Devnet];
        if (!defaultNetwork) {
            throw new Error(`Must provide network.`);
        }
        return defaultNetwork;
    }
    let networkConfig;
    if (renNetwork && (0, exports.isEVMNetworkConfig)(renNetwork)) {
        networkConfig = renNetwork;
    }
    else {
        networkConfig = configMap[renNetwork];
    }
    if (!networkConfig) {
        throw new Error(`Unsupported network '${String(renNetwork
            ? typeof renNetwork === "string"
                ? renNetwork
                : renNetwork.selector
            : renNetwork)}'. Valid options are 'mainnet', 'testnet' or an EVMNetworkConfig object.`);
    }
    return networkConfig;
};
exports.resolveEVMNetworkConfig = resolveEVMNetworkConfig;
/**
 * Resolve an EVM chain's JSON-RPC endpoints, replacing variable keys such as
 * `${INFURA_API_KEY}` with the value provided in `variables`. If a URL has a
 * variable key that isn't provided, it is removed from the final list.
 * If a variable's value is undefined, it is not replaced.
 *
 * @param urls An array of JSON-RPC urls.
 * @param variables An object mapping variable keys to their values.
 * @param protocol A RegExp matching the required url protocol. Defaults to "https"
 * @returns An array of JSON-RPC urls with variables resolved to their values.
 *
 * @example
 * resolveRpcEndpoints(
 *  ["https://test.com/${TEST}", "https://test2.com/${MISSING}", "wss://test3.com"],
 *  { TEST: "test"},
 * )
 * > ["https://test.com/test"]
 */
const resolveRpcEndpoints = (urls, variables, protocol = "https") => [
    ...urls.filter((url) => url.includes("${")),
    ...urls.filter((url) => !url.includes("${")),
]
    // Replace variable keys surround by "${...}" with variable values.
    // If a variable's value is undefined, it is not replaced.
    .map((url) => Object.keys(variables || {}).reduce((urlAcc, variableKey) => urlAcc.replace(`\${${variableKey}}`, (variables || {})[variableKey]
    ? String((variables || {})[variableKey])
    : `\${${variableKey}}`), url))
    // Match only endpoints that don't include any left-over "${"s,
    // and that have the right protocol.
    .filter((url) => url.match(/^[^(${)]*$/) &&
    url.match(typeof protocol === "string" ? "^" + protocol : protocol));
exports.resolveRpcEndpoints = resolveRpcEndpoints;
/**
 *
 * @param provider An ethers.js provider.
 * @param network The config of the EVM network that the signer should be
 * connected to.
 * @returns The result of the comparison, including details of the expected and
 * actual networks. If `result` is true, then the signer's network is correct.
 */
const checkProviderNetwork = async (provider, network) => {
    const expectedNetworkId = new bignumber_js_1.default(network.config.chainId).toNumber();
    const actualNetworkId = provider
        ? (await provider.getNetwork()).chainId
        : expectedNetworkId;
    return {
        result: actualNetworkId === expectedNetworkId,
        actualNetworkId,
        expectedNetworkId,
        expectedNetworkLabel: network.config.chainName,
    };
};
exports.checkProviderNetwork = checkProviderNetwork;
//# sourceMappingURL=generic.js.map