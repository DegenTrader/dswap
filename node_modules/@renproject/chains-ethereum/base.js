"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthereumBaseChain = void 0;
const providers_1 = require("@ethersproject/providers");
const utils_1 = require("@renproject/utils");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const elliptic_1 = __importDefault(require("elliptic"));
const ethers_1 = require("ethers");
const utils_2 = require("ethers/lib/utils");
const contracts_1 = require("./contracts");
const evmTxSubmitter_1 = require("./utils/evmTxSubmitter");
const gatewayRegistry_1 = require("./utils/gatewayRegistry");
const generic_1 = require("./utils/generic");
const evmAddressPayload_1 = require("./utils/payloads/evmAddressPayload");
const evmApprovalPayload_1 = require("./utils/payloads/evmApprovalPayload");
const evmContractPayload_1 = require("./utils/payloads/evmContractPayload");
const evmParams_1 = require("./utils/payloads/evmParams");
const evmTxPayload_1 = require("./utils/payloads/evmTxPayload");
const types_1 = require("./utils/types");
class EthereumBaseChain {
    constructor({ network, provider, signer, config, }) {
        this.assets = {};
        this.configMap = {};
        this.getMintAsset = utils_1.utils.memoize(async (asset) => await (0, gatewayRegistry_1.getRenAsset)(this.network, this.provider, asset));
        this.getRenAsset = this.getMintAsset;
        this.getMintGateway = utils_1.utils.memoize(async (asset) => await (0, gatewayRegistry_1.getMintGateway)(this.network, this.provider, asset));
        this.getLockAsset = utils_1.utils.memoize(async (asset) => await (0, gatewayRegistry_1.getLockAsset)(this.network, this.provider, asset));
        this.getLockGateway = utils_1.utils.memoize(async (asset) => await (0, gatewayRegistry_1.getLockGateway)(this.network, this.provider, asset));
        this.validateAddress = generic_1.validateAddress;
        this.validateTransaction = generic_1.validateTransaction;
        this.addressExplorerLink = (address) => {
            return this.explorer.address(address);
        };
        this.addressToBytes = (address) => {
            return utils_1.utils.fromHex(address);
        };
        this.addressFromBytes = (bytes) => {
            return ethers_1.ethers.utils.getAddress(utils_1.utils.Ox(bytes));
        };
        this.txHashToBytes = (txHash) => {
            return (0, generic_1.txHashToBytes)(txHash);
        };
        this.txHashFromBytes = (bytes) => {
            return (0, generic_1.txHashFromBytes)(bytes);
        };
        this.transactionExplorerLink = ({ txid, txHash, }) => {
            if (txHash) {
                return this.explorer.transaction(txHash);
            }
            else if (txid) {
                return this.explorer.transaction(this.txHashFromBytes(utils_1.utils.fromBase64(txid)));
            }
            return undefined;
        };
        this.withProvider = (web3Provider) => {
            this.provider = providers_1.Provider.isProvider(web3Provider)
                ? web3Provider
                : typeof web3Provider === "string"
                    ? new ethers_1.ethers.providers.JsonRpcProvider(web3Provider)
                    : // TODO: Set chainId instead of "any"?
                        new ethers_1.ethers.providers.Web3Provider(web3Provider, "any");
            if (!this.signer) {
                try {
                    this.signer = this.provider.getSigner();
                }
                catch (error) {
                    // Ignore error.
                }
            }
            else {
                try {
                    this.signer.connect(this.provider);
                }
                catch (error) {
                    // Ignore - doesnt' work on all signers.
                    // e.g. JsonRpc signer throws:
                    // `cannot alter JSON-RPC Signer connection`.
                }
            }
            return this;
        };
        this.withSigner = (signer) => {
            this.signer = signer;
            try {
                this.signer.connect(this.provider);
            }
            catch (error) {
                // Ignore - doesnt' work on all signers.
                // e.g. JsonRpc signer throws:
                // `cannot alter JSON-RPC Signer connection`.
            }
            return this;
        };
        this.checkProviderNetwork = async (provider) => {
            return (0, generic_1.checkProviderNetwork)(provider || this.provider, this.network);
        };
        this.checkProviderNetworkCached = utils_1.utils.memoize(this.checkProviderNetwork, {
            expiry: 10 * utils_1.utils.sleep.SECONDS,
        });
        this.checkSignerNetwork = async () => {
            if (!this.signer) {
                throw new Error(`Must connect ${this.chain} signer.`);
            }
            return (0, generic_1.checkProviderNetwork)(
            // If the signer as no provider, fall back to the provider field.
            this.signer.provider || this.provider, this.network);
        };
        this.switchSignerNetwork = async () => {
            if (!this.signer) {
                throw new Error(`Must connect ${this.chain} signer.`);
            }
            if (!this.signer.provider ||
                !this.signer.provider.send) {
                throw new Error(`Signer doesn't support switching network.`);
            }
            // await (this.signer.provider as JsonRpcProvider).send(
            //     "wallet_switchEthereumChain",
            //     [
            //         {
            //             chainId: this.network.config.chainId,
            //         },
            //     ],
            // );
            await this.signer.provider.send("wallet_addEthereumChain", [this.network.config]);
        };
        this.getOutputPayload = async (asset, inputType, outputType, contractCall) => {
            const providerNetworkCheck = await this.checkProviderNetworkCached();
            if (!providerNetworkCheck.result) {
                throw new utils_1.ErrorWithCode(`Invalid ${this.chain} provider network: expected ${providerNetworkCheck.expectedNetworkId} (${providerNetworkCheck.expectedNetworkLabel}), got ${providerNetworkCheck.actualNetworkId}.`, utils_1.RenJSError.INCORRECT_PROVIDER_NETWORK);
            }
            if (contractCall.type === undefined) {
                return undefined;
            }
            const handler = this.getPayloadHandler(contractCall.type);
            if (!handler.getPayload) {
                throw utils_1.ErrorWithCode.updateError(new Error(`'${contractCall.type}' payload type can only be used as a setup payload.`), utils_1.RenJSError.PARAMETER_ERROR);
            }
            const { to, toBytes, payload } = await handler.getPayload({
                network: this.network,
                signer: this.signer,
                payload: contractCall,
                evmParams: this.getEVMParams(asset, inputType, outputType, outputType, {}),
                getPayloadHandler: this.getPayloadHandler,
            });
            return {
                to: contractCall.payloadConfig &&
                    contractCall.payloadConfig.preserveAddressFormat
                    ? to
                    : ethers_1.ethers.utils.getAddress(to),
                toBytes,
                payload,
            };
        };
        // Supported assets
        /** Return true if the asset originates from the chain. */
        // Wrapper to expose _isLockAsset as a class method instead of a property
        this.isLockAsset = utils_1.utils.memoize(async (assetSymbol) => {
            // Check if it in the list of hard-coded assets.
            if (Object.keys(this.assets).includes(assetSymbol) ||
                assetSymbol === this.network.nativeAsset.symbol) {
                return true;
            }
            // Check if the asset has an associated lock-gateway.
            try {
                if (await this.getLockAsset(assetSymbol)) {
                    return true;
                }
            }
            catch (error) {
                return false;
            }
            return false;
        });
        this.isDepositAsset = (assetSymbol) => {
            return assetSymbol === this.network.nativeAsset.symbol;
        };
        /**
         * `assetIsSupported` should return true if the asset is native to the
         * MintChain.
         *
         * ```ts
         * ethereum.assetIsSupported = asset => asset === "ETH";
         * ```
         */
        this.isMintAsset = utils_1.utils.memoize(async (asset) => {
            // Check that there's a gateway contract for the asset.
            try {
                return (await this.getMintAsset(asset)) !== undefined;
            }
            catch (error) {
                // Check that the error isn't caused by being on the wrong network.
                const providerNetworkCheck = await this.checkProviderNetworkCached();
                if (!providerNetworkCheck.result) {
                    throw new utils_1.ErrorWithCode(`Invalid ${this.chain} provider network: expected ${providerNetworkCheck.expectedNetworkId} (${providerNetworkCheck.expectedNetworkLabel}), got ${providerNetworkCheck.actualNetworkId}.`, utils_1.RenJSError.INCORRECT_PROVIDER_NETWORK);
                }
                if (error instanceof Error &&
                    /(Empty address returned)|(not supported)/.exec(
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
                    String((error || {}).message))) {
                    // Ignore
                }
                else {
                    console.warn(error);
                }
                return false;
            }
        });
        /**
         * `assetDecimals` should return the number of decimals of the asset.
         *
         * If the asset is not supported, an error should be thrown.
         *
         */
        this.assetDecimals = utils_1.utils.memoize(async (asset) => {
            // TODO: get lock asset decimals
            if (asset === this.network.nativeAsset.symbol) {
                return this.network.nativeAsset.decimals;
            }
            let tokenAddress;
            if (await this.isLockAsset(asset)) {
                tokenAddress = await this.getLockAsset(asset);
            }
            else if (await this.isMintAsset(asset)) {
                tokenAddress = await this.getMintAsset(asset);
            }
            else {
                throw new Error(`Asset '${asset}' not supported on ${this.chain}.`);
            }
            const decimalsABI = {
                constant: true,
                inputs: [],
                name: "decimals",
                outputs: [
                    {
                        internalType: "uint256",
                        name: "",
                        type: "uint256",
                    },
                ],
                payable: false,
                stateMutability: "view",
                type: "function",
            };
            const tokenContract = new ethers_1.ethers.Contract(tokenAddress, [decimalsABI], this.provider);
            const decimalsRaw = await tokenContract.decimals();
            return new bignumber_js_1.default(decimalsRaw.toString()).toNumber();
        }, { expiry: false });
        this.transactionConfidence = async (transaction) => {
            if (transaction.txid === "") {
                throw new Error(`Unable to fetch transaction confidence, transaction hash not set.`);
            }
            const currentBlock = new bignumber_js_1.default((await this.provider.getBlockNumber()).toString());
            const receipt = await this.provider.getTransactionReceipt(transaction.txHash);
            if (receipt === null) {
                throw utils_1.ErrorWithCode.updateError(new Error(`${String(transaction.chain)} transaction not found: ${transaction.txHash}`), utils_1.RenJSError.TRANSACTION_NOT_FOUND);
            }
            if (receipt && receipt.blockNumber) {
                const transactionBlock = new bignumber_js_1.default(receipt.blockNumber.toString());
                return currentBlock.minus(transactionBlock).plus(1);
            }
            else {
                return new bignumber_js_1.default(0);
            }
        };
        this.getBalance = async (asset, address) => {
            if (!address) {
                if (!this.signer) {
                    throw new Error(`Must connect ${this.chain} signer or provide address.`);
                }
                address = address || (await this.signer.getAddress());
            }
            if (asset === this.network.nativeAsset.symbol) {
                return new bignumber_js_1.default((await this.provider.getBalance(address)).toString());
            }
            const balanceOfABI = {
                constant: true,
                inputs: [
                    {
                        internalType: "address",
                        name: "account",
                        type: "address",
                    },
                ],
                name: "balanceOf",
                outputs: [
                    {
                        internalType: "uint256",
                        name: "",
                        type: "uint256",
                    },
                ],
                payable: false,
                stateMutability: "view",
                type: "function",
            };
            let tokenAddress;
            if (await this.isMintAsset(asset)) {
                tokenAddress = await this.getMintAsset(asset);
            }
            else if (await this.isLockAsset(asset)) {
                tokenAddress = await this.getLockAsset(asset);
            }
            else {
                throw new Error(`Asset '${asset}' not supported on ${this.chain}.`);
            }
            const tokenContract = new ethers_1.ethers.Contract(tokenAddress, [balanceOfABI], this.provider);
            const balanceRaw = await await tokenContract.balanceOf(address);
            return new bignumber_js_1.default(balanceRaw.toString());
        };
        this.getOutputTx = async (inputType, outputType, asset, contractCall, getParams, confirmationTarget) => {
            const providerNetworkCheck = await this.checkProviderNetworkCached();
            if (!providerNetworkCheck.result) {
                throw new utils_1.ErrorWithCode(`Invalid ${this.chain} provider network: expected ${providerNetworkCheck.expectedNetworkId} (${providerNetworkCheck.expectedNetworkLabel}), got ${providerNetworkCheck.actualNetworkId}.`, utils_1.RenJSError.INCORRECT_PROVIDER_NETWORK);
            }
            const findExistingTransaction = async () => {
                const { nHash, sigHash } = getParams();
                const txHash = outputType === utils_1.OutputType.Release
                    ? await (0, generic_1.findReleaseBySigHash)(this.network, this.provider, asset, nHash, sigHash, this.network.logRequestLimit)
                    : await (0, generic_1.findMintBySigHash)(this.network, this.provider, asset, nHash, sigHash, this.network.logRequestLimit);
                return utils_1.utils.isDefined(txHash)
                    ? (0, generic_1.txHashToChainTransaction)(this.chain, txHash, (this.transactionExplorerLink &&
                        this.transactionExplorerLink({ txHash })) ||
                        "")
                    : undefined;
            };
            const existingTransaction = await findExistingTransaction();
            if (existingTransaction) {
                return new utils_1.DefaultTxWaiter({
                    chainTransaction: existingTransaction,
                    chain: this,
                    target: confirmationTarget,
                });
            }
            // const overrideArray = Object.keys(override || {}).map((key) => ({
            //     name: key,
            //     value: (override || {})[key],
            // }));
            // Override contract call parameters that have been passed in to
            // "mint".
            // contractCall = overrideContractCall(contractCall, {
            //     contractParams: overrideArray,
            // });
            // // Filter parameters that should be included in the payload hash but
            // // not the contract call.
            // contractCalls = contractCalls.map((call) => ({
            //     ...call,
            //     contractParams: call.contractParams
            //         ? call.contractParams.filter((param) => !param.onlyInPayload)
            //         : call.contractParams,
            // }));
            if (contractCall.type === "transaction") {
                return new utils_1.DefaultTxWaiter({
                    chain: this,
                    target: confirmationTarget,
                    chainTransaction: contractCall.params.tx,
                });
            }
            return new evmTxSubmitter_1.EVMTxSubmitter({
                getProvider: () => this.provider,
                getSigner: () => this.signer,
                network: this.network,
                chain: this.chain,
                payload: contractCall,
                target: confirmationTarget,
                getPayloadHandler: this.getPayloadHandler,
                getParams: () => this.getEVMParams(asset, inputType, outputType, outputType, getParams()),
                findExistingTransaction,
                transactionExplorerLink: this.transactionExplorerLink,
            });
        };
        /**
         * Read a burn reference from an Ethereum transaction - or submit a
         * transaction first if the transaction details have been provided.
         */
        this.getInputTx = async (inputType, outputType, asset, contractCall, getParams, confirmationTarget, onInput) => {
            const providerNetworkCheck = await this.checkProviderNetworkCached();
            if (!providerNetworkCheck.result) {
                throw new utils_1.ErrorWithCode(`Invalid ${this.chain} provider network: expected ${providerNetworkCheck.expectedNetworkId} (${providerNetworkCheck.expectedNetworkLabel}), got ${providerNetworkCheck.actualNetworkId}.`, utils_1.RenJSError.INCORRECT_PROVIDER_NETWORK);
            }
            // if (!transaction && burnNonce) {
            //     const nonceBytes = burnNonce instanceof Uint8Array
            //         ? burnNonce
            //         : toNBytes(burnNonce, 32);
            //     return [
            //         await findBurnByNonce(
            //             this.renNetworkDetails,
            //             this.provider,
            //             asset,
            //             nonceBytes,
            //         ),
            //     ];
            // }
            // if (!transaction) {
            //     return undefined;
            // }
            // eventEmitter.emit("transaction", {
            //     txid: transaction.txid,
            //     txindex: "0",
            // });
            // const receipt = await waitForReceipt(
            //     this.provider,
            //     this.txidToTxidFormatted(transaction),
            //     this.logger,
            //     config.networkDelay,
            // );
            // return extractBurnDetails(receipt);
            const onReceipt = (receipt) => {
                if (inputType === utils_1.InputType.Burn) {
                    const logBurnABI = (0, contracts_1.findABIMethod)(contracts_1.MintGatewayABI, "LogBurn");
                    (0, generic_1.filterLogs)(receipt.logs, logBurnABI)
                        .map((e) => (0, generic_1.mapBurnLogToInputChainTransaction)(this.chain, asset, e.event, this.transactionExplorerLink({
                        txHash: e.log.transactionHash,
                    }) || ""))
                        .map(onInput);
                    // Filter logs that are releases to other chains.
                    const { toChain: receiptToChain } = getParams();
                    const filterByRecipientChain = (e) => {
                        const [_recipientAddress, recipientChain] = e.event.args;
                        return recipientChain === receiptToChain;
                    };
                    const logBurnToChainABI = (0, contracts_1.findABIMethod)(contracts_1.MintGatewayABI, "LogBurnToChain");
                    (0, generic_1.filterLogs)(receipt.logs, logBurnToChainABI)
                        .filter(filterByRecipientChain)
                        .map((e) => (0, generic_1.mapBurnToChainLogToInputChainTransaction)(this.chain, asset, e.event, this.transactionExplorerLink({
                        txHash: e.log.transactionHash,
                    }) || ""))
                        .map(onInput);
                }
                else {
                    const logLockABI = (0, contracts_1.findABIMethod)(contracts_1.LockGatewayABI, "LogLockToChain");
                    const lockEvents = (0, generic_1.filterLogs)(receipt.logs, logLockABI).map((e) => (0, generic_1.mapLockLogToInputChainTransaction)(this.chain, asset, e.event, this.transactionExplorerLink({
                        txHash: e.log.transactionHash,
                    }) || ""));
                    lockEvents.map(onInput);
                    const logTransferredABI = (0, contracts_1.findABIMethod)(contracts_1.TransferWithLogABI, "LogTransferred");
                    const transferEvents = (0, generic_1.filterLogs)(receipt.logs, logTransferredABI).map((e) => (0, generic_1.mapTransferLogToInputChainTransaction)(this.chain, asset, e.event, this.transactionExplorerLink({
                        txHash: e.log.transactionHash,
                    }) || ""));
                    transferEvents.map(onInput);
                    if (lockEvents.length === 0 && transferEvents.length === 0) {
                        throw new Error(`No inputs found in transaction ${receipt.transactionHash}.`);
                    }
                }
            };
            if (contractCall.type === "transaction") {
                return new utils_1.DefaultTxWaiter({
                    chain: this,
                    target: confirmationTarget,
                    chainTransaction: contractCall.params.tx,
                    onFirstProgress: async (tx) => {
                        onReceipt(await this.provider.getTransactionReceipt(tx.txHash));
                    },
                });
            }
            if (contractCall.type === "nonce") {
                const nonce = utils_1.utils.toNBytes(new bignumber_js_1.default(contractCall.params.nonce), 32);
                const chainTransaction = await (0, generic_1.findInputByNonce)(this.chain, inputType, this.network, this.provider, asset, nonce, this.transactionExplorerLink);
                if (!chainTransaction) {
                    throw new Error(`Unable to find ${asset} ${inputType} on ${this.chain} with nonce ${String(contractCall.params.nonce)}.`);
                }
                return new utils_1.DefaultTxWaiter({
                    chain: this,
                    target: confirmationTarget,
                    chainTransaction,
                    onFirstProgress: async (tx) => {
                        onReceipt(await this.provider.getTransactionReceipt(tx.txHash));
                    },
                });
            }
            // const { toChain, toPayload } = getParams();
            // if (!toPayload) {
            //     throw new Error(
            //         `Unable to generate ${this.chain} transaction: No ${toChain} payload.`,
            //     );
            // }
            return new evmTxSubmitter_1.EVMTxSubmitter({
                getProvider: () => this.provider,
                getSigner: () => this.signer,
                network: this.network,
                chain: this.chain,
                payload: contractCall,
                target: confirmationTarget,
                getPayloadHandler: this.getPayloadHandler,
                getParams: () => this.getEVMParams(asset, inputType, outputType, inputType, getParams()),
                onReceipt: onReceipt,
                transactionExplorerLink: this.transactionExplorerLink,
            });
        };
        this.getInSetup = async (asset, inputType, outputType, contractCall, getParams) => {
            if (!contractCall.type) {
                return {};
            }
            const handler = this.getPayloadHandler(contractCall.type);
            if (!handler || !handler.getSetup) {
                return {};
            }
            const calls = await handler.getSetup({
                network: this.network,
                signer: this.signer,
                payload: contractCall,
                evmParams: this.getEVMParams(asset, inputType, outputType, inputType, getParams()),
                getPayloadHandler: this.getPayloadHandler,
            });
            const txSubmitted = {};
            for (const callKey of Object.keys(calls)) {
                if (calls[callKey].type === "transaction") {
                    txSubmitted[callKey] = new utils_1.DefaultTxWaiter({
                        chain: this,
                        target: 1,
                        chainTransaction: calls[callKey].params
                            .tx,
                    });
                }
                else {
                    txSubmitted[callKey] = new evmTxSubmitter_1.EVMTxSubmitter({
                        getProvider: () => this.provider,
                        getSigner: () => this.signer,
                        network: this.network,
                        chain: this.chain,
                        payload: calls[callKey],
                        target: 1,
                        getPayloadHandler: this.getPayloadHandler,
                        getParams: () => this.getEVMParams(asset, inputType, outputType, inputType, getParams()),
                        transactionExplorerLink: this.transactionExplorerLink,
                    });
                }
            }
            return txSubmitted;
        };
        this.getOutSetup = async (asset, inputType, outputType, contractCall, getParams) => {
            if (!contractCall.type) {
                return {};
            }
            const handler = this.getPayloadHandler(contractCall.type);
            if (!handler || !handler.getSetup) {
                return {};
            }
            const calls = await handler.getSetup({
                network: this.network,
                signer: this.signer,
                payload: contractCall,
                evmParams: this.getEVMParams(asset, inputType, outputType, outputType, getParams()),
                getPayloadHandler: this.getPayloadHandler,
            });
            const txSubmitted = {};
            for (const callKey of Object.keys(calls)) {
                if (calls[callKey].type === "transaction") {
                    txSubmitted[callKey] = new utils_1.DefaultTxWaiter({
                        chain: this,
                        target: 1,
                        chainTransaction: calls[callKey].params
                            .tx,
                    });
                }
                else {
                    txSubmitted[callKey] = new evmTxSubmitter_1.EVMTxSubmitter({
                        getProvider: () => this.provider,
                        getSigner: () => this.signer,
                        network: this.network,
                        chain: this.chain,
                        payload: calls[callKey],
                        target: 1,
                        getPayloadHandler: this.getPayloadHandler,
                        getParams: () => this.getEVMParams(asset, inputType, outputType, outputType, getParams()),
                        transactionExplorerLink: this.transactionExplorerLink,
                    });
                }
            }
            return txSubmitted;
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.getPayloadHandler = (payloadType) => {
            switch (payloadType) {
                case "approval":
                    return evmApprovalPayload_1.approvalPayloadHandler;
                case "contract":
                    return evmContractPayload_1.contractPayloadHandler;
                case "address":
                    return evmAddressPayload_1.accountPayloadHandler;
                case "transaction":
                    return evmTxPayload_1.txPayloadHandler;
            }
            // TODO: Allow adding custom payload handlers.
            throw new Error(`Unknown payload type ${payloadType}`);
        };
        this.createGatewayAddress = (_asset, fromPayload, shardPublicKey, gHash) => {
            if (fromPayload.chain !== this.chain) {
                throw new Error(`Invalid payload for chain ${fromPayload.chain} instead of ${this.chain}.`);
            }
            const ec = new elliptic_1.default.ec("secp256k1");
            // Decode compressed RenVM public key.
            const renVMPublicKey = ec.keyFromPublic(shardPublicKey);
            // Interpret gHash as a private key.
            const gHashKey = ec.keyFromPrivate(gHash);
            // If `NO_PARAMS_FLAG` is set, set renVM public key and gHash public key,
            // and recreate key pair from resulting curve point.
            const derivedPublicKey = ec.keyFromPublic(renVMPublicKey
                .getPublic()
                .add(gHashKey.getPublic()));
            return (0, utils_2.computeAddress)(utils_1.utils.fromHex(derivedPublicKey.getPublic(false, "hex")));
        };
        this.getEVMParams = (asset, inputType, outputType, transactionType, params) => {
            return {
                // Always available
                [evmParams_1.EVMParam.EVM_INPUT_TYPE]: inputType,
                [evmParams_1.EVMParam.EVM_OUTPUT_TYPE]: outputType,
                [evmParams_1.EVMParam.EVM_TRANSACTION_TYPE]: transactionType,
                [evmParams_1.EVMParam.EVM_TOKEN_ADDRESS]: async () => {
                    if (transactionType === utils_1.InputType.Lock ||
                        transactionType === utils_1.OutputType.Release) {
                        return await this.getLockAsset(asset);
                    }
                    else {
                        return await this.getMintAsset(asset);
                    }
                },
                [evmParams_1.EVMParam.EVM_TOKEN_DECIMALS]: async () => await this.assetDecimals(asset),
                [evmParams_1.EVMParam.EVM_ACCOUNT]: async () => {
                    if (!this.signer) {
                        throw utils_1.ErrorWithCode.updateError(new Error(`Must connect ${this.chain} signer.`), utils_1.RenJSError.PARAMETER_ERROR);
                    }
                    try {
                        return await this.signer.getAddress();
                    }
                    catch (error) {
                        if (utils_1.ErrorWithCode.isErrorWithCode(error) &&
                            error.code === ethers_1.errors.UNSUPPORTED_OPERATION) {
                            throw utils_1.ErrorWithCode.updateError(new Error(`Must connect ${this.chain} signer - unable to get address.`), utils_1.RenJSError.PARAMETER_ERROR);
                        }
                        throw error;
                    }
                },
                [evmParams_1.EVMParam.EVM_ACCOUNT_IS_CONTRACT]: async () => {
                    if (!this.signer) {
                        throw utils_1.ErrorWithCode.updateError(new Error(`Must connect ${this.chain} signer.`), utils_1.RenJSError.PARAMETER_ERROR);
                    }
                    try {
                        const account = await this.signer.getAddress();
                        const codeString = await this.provider.getCode(account);
                        return utils_1.utils.fromHex(codeString).length > 0;
                    }
                    catch (error) {
                        if (utils_1.ErrorWithCode.isErrorWithCode(error) &&
                            error.code === ethers_1.errors.UNSUPPORTED_OPERATION) {
                            throw utils_1.ErrorWithCode.updateError(new Error(`Must connect ${this.chain} signer - unable to get code at address.`), utils_1.RenJSError.PARAMETER_ERROR);
                        }
                        throw error;
                    }
                },
                [evmParams_1.EVMParam.EVM_GATEWAY]: async () => {
                    if (transactionType === utils_1.InputType.Lock ||
                        transactionType === utils_1.OutputType.Release) {
                        return await this.getLockGateway(asset);
                    }
                    else {
                        return await this.getMintGateway(asset);
                    }
                },
                [evmParams_1.EVMParam.EVM_TRANSFER_WITH_LOG_CONTRACT]: async () => await (0, contracts_1.getGatewayRegistryInstance)(this.provider, this.network.addresses.GatewayRegistry).getTransferContract(),
                [evmParams_1.EVMParam.EVM_ASSET]: asset,
                [evmParams_1.EVMParam.EVM_CHAIN]: this.chain,
                // Available when minting or releasing
                [evmParams_1.EVMParam.EVM_AMOUNT]: utils_1.utils.isDefined(params.amount)
                    ? params.amount.toFixed()
                    : undefined,
                [evmParams_1.EVMParam.EVM_NHASH]: params.nHash,
                [evmParams_1.EVMParam.EVM_PHASH]: params.pHash,
                [evmParams_1.EVMParam.EVM_SIGNATURE]: params.signature,
                [evmParams_1.EVMParam.EVM_SIGNATURE_R]: utils_1.utils.isDefined(params.signature)
                    ? params.signature.slice(0, 32)
                    : undefined,
                [evmParams_1.EVMParam.EVM_SIGNATURE_S]: utils_1.utils.isDefined(params.signature)
                    ? params.signature.slice(32, 64)
                    : undefined,
                [evmParams_1.EVMParam.EVM_SIGNATURE_V]: utils_1.utils.isDefined(params.signature)
                    ? params.signature.slice(64, 65)[0]
                    : undefined,
                // Available when locking or burning
                [evmParams_1.EVMParam.EVM_TO_CHAIN]: params.toChain,
                [evmParams_1.EVMParam.EVM_TO_ADDRESS_BYTES]: utils_1.utils.isDefined(params.toPayload)
                    ? utils_1.utils.fromUTF8String(params.toPayload.to)
                    : undefined,
                [evmParams_1.EVMParam.EVM_TO_ADDRESS]: utils_1.utils.isDefined(params.toPayload)
                    ? params.toPayload.to
                    : undefined,
                [evmParams_1.EVMParam.EVM_TO_PAYLOAD]: utils_1.utils.isDefined(params.toPayload)
                    ? params.toPayload.payload
                    : undefined,
                [evmParams_1.EVMParam.EVM_GATEWAY_DEPOSIT_ADDRESS]: params.gatewayAddress,
                [evmParams_1.EVMParam.EVM_GATEWAY_IS_DEPOSIT_ASSET]: this.isDepositAsset(asset),
            };
        };
        /* ====================================================================== */
        this.Account = ({ account, amount, convertUnit, anyoneCanSubmit, infiniteApproval, payloadConfig, } = {}) => {
            (0, utils_1.assertType)("BigNumber | string | number | undefined", { amount });
            (0, utils_1.assertType)("boolean | undefined", {
                convertUnit,
            });
            let fixedAmount;
            if (utils_1.utils.isDefined(amount)) {
                fixedAmount = bignumber_js_1.default.isBigNumber(amount)
                    ? amount
                    : new bignumber_js_1.default(amount.toString());
                if (fixedAmount.isNaN()) {
                    throw utils_1.ErrorWithCode.updateError(new Error(`Invalid numeric-value 'amount'. (amount: ${amount.toString()})`), utils_1.RenJSError.PARAMETER_ERROR);
                }
                else if (!convertUnit && fixedAmount.decimalPlaces() !== 0) {
                    throw utils_1.ErrorWithCode.updateError(new Error(`Amount must be provided in Wei as an integer, or 'convertUnit' must be set to 'true'. (amount: ${amount.toString()})`), utils_1.RenJSError.PARAMETER_ERROR);
                }
            }
            if (account && account.slice(0, 5) !== "__EVM") {
                if (!this.validateAddress(account)) {
                    new utils_1.ErrorWithCode(`Invalid ${this.chain} address: ${String(account)}`, utils_1.RenJSError.PARAMETER_ERROR);
                }
                if (!(payloadConfig && payloadConfig.preserveAddressFormat)) {
                    // Convert to checksum account.
                    account = ethers_1.ethers.utils.getAddress(account);
                }
            }
            return {
                chain: this.chain,
                type: "address",
                params: {
                    address: account || evmParams_1.EVMParam.EVM_ACCOUNT,
                    amount: fixedAmount ? fixedAmount.toFixed() : undefined,
                    convertUnit,
                    anyoneCanSubmit,
                    infiniteApproval,
                },
                payloadConfig,
            };
        };
        this.Address = (address, payloadConfig) => {
            (0, utils_1.assertType)("string", {
                address,
            });
            if (address.slice(0, 5) !== "__EVM") {
                if (!this.validateAddress(address)) {
                    new utils_1.ErrorWithCode(`Invalid ${this.chain} address: ${String(address)}`, utils_1.RenJSError.PARAMETER_ERROR);
                }
                if (!(payloadConfig && payloadConfig.preserveAddressFormat)) {
                    // Convert to checksum address.
                    address = ethers_1.ethers.utils.getAddress(address);
                }
            }
            return {
                chain: this.chain,
                type: "address",
                params: {
                    address,
                    anyoneCanSubmit: true,
                },
                payloadConfig,
            };
        };
        this.Contract = (params) => {
            let { to } = params;
            if (to.slice(0, 5) !== "__EVM") {
                if (!this.validateAddress(to)) {
                    new utils_1.ErrorWithCode(`Invalid ${this.chain} contract address: ${String(to)}`, utils_1.RenJSError.PARAMETER_ERROR);
                }
                if (!(params.payloadConfig &&
                    params.payloadConfig.preserveAddressFormat)) {
                    // Convert to checksum address.
                    to = ethers_1.ethers.utils.getAddress(to);
                }
            }
            return {
                chain: this.chain,
                type: "contract",
                params: {
                    to,
                    method: params.method,
                    params: [
                        ...params.params,
                        ...(params.withRenParams
                            ? [
                                {
                                    name: "amount",
                                    type: "uint256",
                                    value: evmParams_1.EVMParam.EVM_AMOUNT,
                                    notInPayload: true,
                                    renParam: true,
                                },
                                {
                                    name: "nHash",
                                    type: "bytes32",
                                    value: evmParams_1.EVMParam.EVM_NHASH,
                                    notInPayload: true,
                                    renParam: true,
                                },
                                {
                                    name: "signature",
                                    type: "bytes",
                                    value: evmParams_1.EVMParam.EVM_SIGNATURE,
                                    notInPayload: true,
                                    renParam: true,
                                },
                            ]
                            : []),
                    ],
                    txConfig: params.txConfig,
                },
                payloadConfig: params.payloadConfig,
            };
        };
        /**
         * Import an existing Ethereum transaction.
         *
         * @example
         * ethereum.Transaction({
         *   txHash: "0xf7dbf98bcebd7b803917e00e7e3292843a4b7bf66016638811cea4705a32d73e",
         * })
         */
        this.Transaction = (partialTx, payloadConfig) => {
            return {
                chain: this.chain,
                type: "transaction",
                params: {
                    tx: (0, utils_1.populateChainTransaction)({
                        partialTx,
                        chain: this.chain,
                        txHashToBytes: generic_1.txHashToBytes,
                        txHashFromBytes: generic_1.txHashFromBytes,
                        defaultTxindex: "0",
                        explorerLink: this.transactionExplorerLink,
                    }),
                },
                payloadConfig,
            };
        };
        this.network = (0, generic_1.resolveEVMNetworkConfig)(this.configMap, network);
        this.chain = this.network.selector;
        this.explorer = (0, types_1.StandardEVMExplorer)(this.network.config.blockExplorerUrls[0]);
        this._logger = (config && config.logger) || utils_1.defaultLogger;
        this._config = config;
        // Ignore not configured error.
        this.provider = undefined;
        this.withProvider(provider);
        if (signer) {
            this.withSigner(signer);
        }
    }
}
exports.EthereumBaseChain = EthereumBaseChain;
EthereumBaseChain.configMap = {};
//# sourceMappingURL=base.js.map