import { Token } from "../../core/blockchain/tokens/token";
import { BlockchainName } from "../../core/blockchain/models/blockchain-name";
import { CcrTypedTradeProviders } from "./models/typed-trade-provider";
import { SwapManagerCrossChainCalculationOptions } from "./models/swap-manager-cross-chain-options";
import { WrappedCrossChainTrade } from "./providers/common/models/wrapped-cross-chain-trade";
import { Observable } from 'rxjs';
import { CrossChainProviderData } from "./providers/common/models/cross-chain-provider-data";
/**
 * Contains method to calculate best cross chain trade.
 */
export declare class CrossChainManager {
    private readonly providerAddress;
    private static readonly defaultCalculationTimeout;
    private static readonly defaultSlippageTolerance;
    private static readonly defaultDeadline;
    readonly tradeProviders: CcrTypedTradeProviders;
    constructor(providerAddress: string);
    /**
     * Calculates cross chain trades and sorts them by exchange courses.
     * Wrapped trade object may contain error, but sometimes course can be
     * calculated even with thrown error (e.g. min/max amount error).
     *
     * @example
     * ```ts
     * const fromBlockchain = BLOCKCHAIN_NAME.ETHEREUM;
     * // ETH
     * const fromTokenAddress = '0x0000000000000000000000000000000000000000';
     * const fromAmount = 1;
     * const toBlockchain = BLOCKCHAIN_NAME.BINANCE_SMART_CHAIN;
     * // BUSD
     * const toTokenAddress = '0xe9e7cea3dedca5984780bafc599bd69add087d56';
     *
     * const wrappedTrades = await sdk.crossChain.calculateTrade(
     *     { blockchain: fromBlockchain, address: fromTokenAddress },
     *     fromAmount,
     *     { blockchain: toBlockchain, address: toTokenAddress }
     * );
     * const bestTrade = wrappedTrades[0];
     *
     * wrappedTrades.forEach(wrappedTrade => {
     *    if (wrappedTrade.trade) {
     *        console.log(wrappedTrade.tradeType, `to amount: ${wrappedTrade.trade.to.tokenAmount.toFormat(3)}`));
     *    }
     *    if (wrappedTrade.error) {
     *        console.error(wrappedTrade.tradeType, 'error: wrappedTrade.error');
     *    }
     * });
     *
     * ```
     *
     * @param fromToken Token to sell.
     * @param fromAmount Amount to sell.
     * @param toToken Token to get.
     * @param options Additional options.
     * @returns Array of sorted wrapped cross chain trades with possible errors.
     */
    calculateTrade(fromToken: Token | {
        address: string;
        blockchain: BlockchainName;
    }, fromAmount: string | number, toToken: Token | {
        address: string;
        blockchain: BlockchainName;
    }, options?: Omit<SwapManagerCrossChainCalculationOptions, 'providerAddress'>): Promise<WrappedCrossChainTrade[]>;
    /**
     * Calculates cross chain trades reactively in sequence.
     * Contains wrapped trade object which may contain error, but sometimes course can be
     * calculated even with thrown error (e.g. min/max amount error).
     *
     * @example
     * ```ts
     * const fromBlockchain = BLOCKCHAIN_NAME.ETHEREUM;
     * // ETH
     * const fromTokenAddress = '0x0000000000000000000000000000000000000000';
     * const fromAmount = 1;
     * const toBlockchain = BLOCKCHAIN_NAME.BINANCE_SMART_CHAIN;
     * // BUSD
     * const toTokenAddress = '0xe9e7cea3dedca5984780bafc599bd69add087d56';
     *
     * sdk.crossChain.calculateTrade(
     *     { blockchain: fromBlockchain, address: fromTokenAddress },
     *     fromAmount,
     *     { blockchain: toBlockchain, address: toTokenAddress }
     * ).subscribe(tradeData => {
     *     console.log(tradeData.totalProviders) // 3
     *     console.log(tradeData.calculatedProviders) // 0 -> 1 -> ... -> totalProviders
     *      if (tradeData.bestTrade.trade) {
     *        console.log(wrappedTrade.tradeType, `to amount: ${wrappedTrade.trade.to.tokenAmount.toFormat(3)}`));
     *    }
     *    if (tradeData.bestTrade.error) {
     *        console.error(wrappedTrade.tradeType, 'error: wrappedTrade.error');
     *    }
     * });
     *
     * ```
     *
     * @param fromToken Token to sell.
     * @param fromAmount Amount to sell.
     * @param toToken Token to get.
     * @param options Additional options.
     * @returns Observable of cross chain providers calculation data with best trade and possible errors.
     */
    calculateTradesReactively(fromToken: Token | {
        address: string;
        blockchain: BlockchainName;
    }, fromAmount: string | number, toToken: Token | {
        address: string;
        blockchain: BlockchainName;
    }, options?: Omit<SwapManagerCrossChainCalculationOptions, 'providerAddress'>): Observable<CrossChainProviderData>;
    /**
     * Choose the best provider between two trades.
     * @param nextWrappedTrade New trade to compare.
     * @param prevWrappedTrade Old trade to compare.
     */
    private chooseBestProvider;
    private getFullOptions;
    private calculateBestTradeFromTokens;
    private getProviderRatio;
    private calculateTradeFromTokens;
}
