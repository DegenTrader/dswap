"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogsDecoder = void 0;
var web3_utils_1 = require("web3-utils");
var web3_1 = __importDefault(require("web3"));
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var LogsDecoder = /** @class */ (function () {
    function LogsDecoder() {
    }
    /**
     * Converts abi type to string.
     * @param input Abi input.
     */
    LogsDecoder.typeToString = function (input) {
        var _a;
        if (input.type === 'tuple') {
            return "(".concat((_a = input === null || input === void 0 ? void 0 : input.components) === null || _a === void 0 ? void 0 : _a.map(LogsDecoder.typeToString).join(','), ")");
        }
        return input.type;
    };
    /**
     * Constructs methods ids from contract events items.
     * @param abiItems Abi items.
     */
    LogsDecoder.constructMethodIds = function (abiItems) {
        return abiItems.reduce(function (allItems, abiItem) {
            var _a;
            var _b;
            if (abiItem.name) {
                var sig = (0, web3_utils_1.sha3)("".concat(abiItem.name, "(").concat((_b = abiItem === null || abiItem === void 0 ? void 0 : abiItem.inputs) === null || _b === void 0 ? void 0 : _b.map(LogsDecoder.typeToString), ")"));
                if (abiItem.type === 'event' && sig) {
                    return __assign(__assign({}, allItems), (_a = {}, _a[sig.slice(2)] = abiItem, _a));
                }
                return allItems;
            }
            return allItems;
        }, {});
    };
    /**
     * Constructs date types from method abi.
     * @param method Method abi item.
     */
    LogsDecoder.constructDataTypes = function (method) {
        return method.inputs.reduce(function (types, input) { return (input.indexed ? types : __spreadArray(__spreadArray([], types, true), [input.type], false)); }, []);
    };
    /**
     * Decodes log params.
     * @param method Method abi tem.
     * @param logItem Log item.
     * @param decodedData Decoded data.
     */
    LogsDecoder.decodeParams = function (method, logItem, decodedData) {
        var dataIndex = 0;
        var topicsIndex = 1;
        // Loop topic and data to get the params
        return ((method === null || method === void 0 ? void 0 : method.inputs) || []).map(function (input) {
            var _a;
            var decodedLogData = { name: input.name, type: input.type };
            if (input.indexed) {
                decodedLogData.value = logItem.topics[topicsIndex];
                topicsIndex++;
            }
            else {
                decodedLogData.value = decodedData[dataIndex];
                dataIndex++;
            }
            if (input.type === 'address') {
                decodedLogData.value = (_a = decodedLogData === null || decodedLogData === void 0 ? void 0 : decodedLogData.value) === null || _a === void 0 ? void 0 : _a.toLowerCase();
                // 42 because len(0x) + 40
                if (decodedLogData.value.length > 42) {
                    var toRemove = decodedLogData.value.length - 42;
                    var temp = decodedLogData.value.split('');
                    temp.splice(2, toRemove);
                    decodedLogData.value = temp.join('');
                }
            }
            if (input.type === 'uint256' || input.type === 'uint8' || input.type === 'int') {
                // ensure to remove leading 0x for hex numbers
                if (typeof decodedLogData.value === 'string' &&
                    decodedLogData.value.startsWith('0x') &&
                    decodedLogData.value) {
                    decodedLogData.value = new bignumber_js_1.default(decodedLogData.value.slice(2), 16).toString(10);
                }
                else {
                    decodedLogData.value = new bignumber_js_1.default(decodedLogData.value).toString(10);
                }
            }
            return decodedLogData;
        });
    };
    LogsDecoder.decodeMethod = function (method, logItem) {
        var abiCoder = new web3_1.default().eth.abi;
        var logData = logItem.data;
        var dataTypes = LogsDecoder.constructDataTypes(method);
        var decodedData = abiCoder.decodeParameters(dataTypes, logData.slice(2));
        var decodedParams = LogsDecoder.decodeParams(method, logItem, decodedData);
        return {
            name: method.name,
            params: decodedParams,
            address: logItem.address
        };
    };
    /**
     * private static for decoding transaction logs
     * @param abi Contract ABI
     * @param receipt Transaction receipt
     * @returns Array of decoded logs
     */
    LogsDecoder.decodeLogs = function (abi, receipt) {
        var methodIds = LogsDecoder.constructMethodIds(abi);
        var logs = receipt.logs.filter(function (log) { return log.topics.length > 0; });
        return logs
            .map(function (logItem) {
            var _a, _b;
            var methodID = (_b = (_a = logItem === null || logItem === void 0 ? void 0 : logItem.topics) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.slice(2);
            var method = methodIds[methodID];
            if (method) {
                return LogsDecoder.decodeMethod(method, logItem);
            }
            return null;
        })
            .filter(Boolean);
    };
    return LogsDecoder;
}());
exports.LogsDecoder = LogsDecoder;
//# sourceMappingURL=decode-logs.js.map