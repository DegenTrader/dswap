"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CrossChainManager = void 0;
var token_1 = require("../../core/blockchain/tokens/token");
var object_1 = require("../../common/utils/object");
var rubic_sdk_error_1 = require("../../common/errors/rubic-sdk.error");
var options_1 = require("../../common/utils/options");
var tokens_1 = require("../../common/utils/tokens");
var celer_cross_chain_trade_provider_1 = require("./providers/celer-trade-provider/celer-cross-chain-trade-provider");
var features_1 = require("..");
var p_timeout_1 = __importDefault(require("../../common/utils/p-timeout"));
var cross_chain_trade_provider_1 = require("./providers/common/cross-chain-trade-provider");
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var rxjs_1 = require("rxjs");
var lifi_cross_chain_trade_1 = require("./providers/lifi-trade-provider/lifi-cross-chain-trade");
var cross_chain_min_amount_error_1 = require("../../common/errors/cross-chain/cross-chain-min-amount.error");
var cross_chain_max_amount_error_1 = require("../../common/errors/cross-chain/cross-chain-max-amount.error");
var via_cross_chain_trade_provider_1 = require("./providers/via-trade-provider/via-cross-chain-trade-provider");
var debridge_cross_chain_trade_provider_1 = require("./providers/debridge-trade-provider/debridge-cross-chain-trade-provider");
var symbiosis_cross_chain_trade_provider_1 = require("./providers/symbiosis-trade-provider/symbiosis-cross-chain-trade-provider");
var lifi_cross_chain_trade_provider_1 = require("./providers/lifi-trade-provider/lifi-cross-chain-trade-provider");
var rubic_cross_chain_trade_provider_1 = require("./providers/rubic-trade-provider/rubic-cross-chain-trade-provider");
var via_cross_chain_trade_1 = require("./providers/via-trade-provider/via-cross-chain-trade");
var debridge_cross_chain_trade_1 = require("./providers/debridge-trade-provider/debridge-cross-chain-trade");
/**
 * Contains method to calculate best cross chain trade.
 */
var CrossChainManager = /** @class */ (function () {
    function CrossChainManager(providerAddress) {
        this.providerAddress = providerAddress;
        this.tradeProviders = [
            rubic_cross_chain_trade_provider_1.RubicCrossChainTradeProvider,
            celer_cross_chain_trade_provider_1.CelerCrossChainTradeProvider,
            symbiosis_cross_chain_trade_provider_1.SymbiosisCrossChainTradeProvider,
            lifi_cross_chain_trade_provider_1.LifiCrossChainTradeProvider,
            debridge_cross_chain_trade_provider_1.DebridgeCrossChainTradeProvider,
            via_cross_chain_trade_provider_1.ViaCrossChainTradeProvider
        ].reduce(function (acc, ProviderClass) {
            var provider = new ProviderClass();
            acc[provider.type] = provider;
            return acc;
        }, {});
    }
    /**
     * Calculates cross chain trades and sorts them by exchange courses.
     * Wrapped trade object may contain error, but sometimes course can be
     * calculated even with thrown error (e.g. min/max amount error).
     *
     * @example
     * ```ts
     * const fromBlockchain = BLOCKCHAIN_NAME.ETHEREUM;
     * // ETH
     * const fromTokenAddress = '0x0000000000000000000000000000000000000000';
     * const fromAmount = 1;
     * const toBlockchain = BLOCKCHAIN_NAME.BINANCE_SMART_CHAIN;
     * // BUSD
     * const toTokenAddress = '0xe9e7cea3dedca5984780bafc599bd69add087d56';
     *
     * const wrappedTrades = await sdk.crossChain.calculateTrade(
     *     { blockchain: fromBlockchain, address: fromTokenAddress },
     *     fromAmount,
     *     { blockchain: toBlockchain, address: toTokenAddress }
     * );
     * const bestTrade = wrappedTrades[0];
     *
     * wrappedTrades.forEach(wrappedTrade => {
     *    if (wrappedTrade.trade) {
     *        console.log(wrappedTrade.tradeType, `to amount: ${wrappedTrade.trade.to.tokenAmount.toFormat(3)}`));
     *    }
     *    if (wrappedTrade.error) {
     *        console.error(wrappedTrade.tradeType, 'error: wrappedTrade.error');
     *    }
     * });
     *
     * ```
     *
     * @param fromToken Token to sell.
     * @param fromAmount Amount to sell.
     * @param toToken Token to get.
     * @param options Additional options.
     * @returns Array of sorted wrapped cross chain trades with possible errors.
     */
    CrossChainManager.prototype.calculateTrade = function (fromToken, fromAmount, toToken, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, from, to;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (toToken instanceof token_1.Token && fromToken.blockchain === toToken.blockchain) {
                            throw new rubic_sdk_error_1.RubicSdkError('Blockchains of from and to tokens must be different.');
                        }
                        return [4 /*yield*/, (0, tokens_1.getPriceTokensFromInputTokens)(fromToken, fromAmount.toString(), toToken)];
                    case 1:
                        _a = _b.sent(), from = _a.from, to = _a.to;
                        return [2 /*return*/, this.calculateBestTradeFromTokens(from, to, this.getFullOptions(options))];
                }
            });
        });
    };
    /**
     * Calculates cross chain trades reactively in sequence.
     * Contains wrapped trade object which may contain error, but sometimes course can be
     * calculated even with thrown error (e.g. min/max amount error).
     *
     * @example
     * ```ts
     * const fromBlockchain = BLOCKCHAIN_NAME.ETHEREUM;
     * // ETH
     * const fromTokenAddress = '0x0000000000000000000000000000000000000000';
     * const fromAmount = 1;
     * const toBlockchain = BLOCKCHAIN_NAME.BINANCE_SMART_CHAIN;
     * // BUSD
     * const toTokenAddress = '0xe9e7cea3dedca5984780bafc599bd69add087d56';
     *
     * sdk.crossChain.calculateTrade(
     *     { blockchain: fromBlockchain, address: fromTokenAddress },
     *     fromAmount,
     *     { blockchain: toBlockchain, address: toTokenAddress }
     * ).subscribe(tradeData => {
     *     console.log(tradeData.totalProviders) // 3
     *     console.log(tradeData.calculatedProviders) // 0 -> 1 -> ... -> totalProviders
     *      if (tradeData.bestTrade.trade) {
     *        console.log(wrappedTrade.tradeType, `to amount: ${wrappedTrade.trade.to.tokenAmount.toFormat(3)}`));
     *    }
     *    if (tradeData.bestTrade.error) {
     *        console.error(wrappedTrade.tradeType, 'error: wrappedTrade.error');
     *    }
     * });
     *
     * ```
     *
     * @param fromToken Token to sell.
     * @param fromAmount Amount to sell.
     * @param toToken Token to get.
     * @param options Additional options.
     * @returns Observable of cross chain providers calculation data with best trade and possible errors.
     */
    CrossChainManager.prototype.calculateTradesReactively = function (fromToken, fromAmount, toToken, options) {
        var _this = this;
        if (toToken instanceof token_1.Token && fromToken.blockchain === toToken.blockchain) {
            throw new rubic_sdk_error_1.RubicSdkError('Blockchains of from and to tokens must be different.');
        }
        return (0, rxjs_1.from)((0, tokens_1.getPriceTokensFromInputTokens)(fromToken, fromAmount.toString(), toToken)).pipe((0, rxjs_1.switchMap)(function (tokens) {
            var from = tokens.from, to = tokens.to;
            var _a = _this.getFullOptions(options), disabledProviders = _a.disabledProviders, providersOptions = __rest(_a, ["disabledProviders"]);
            var providers = Object.entries(_this.tradeProviders).filter(function (_a) {
                var type = _a[0], provider = _a[1];
                if (disabledProviders.includes(type)) {
                    return false;
                }
                return provider.isSupportedBlockchains(from.blockchain, to.blockchain);
            });
            var providerData = {
                bestProvider: null,
                totalProviders: providers.length,
                calculatedProviders: -1,
                allProviders: []
            };
            if (!providers.length) {
                throw new rubic_sdk_error_1.RubicSdkError("There are no providers for trade");
            }
            var tradeObservable$ = (0, rxjs_1.merge)((0, rxjs_1.of)((0, p_timeout_1.default)(new Promise(function (resolve) { return resolve(null); }), Infinity)), (0, rxjs_1.from)(providers.map(function (_a) {
                var type = _a[0], provider = _a[1];
                return __awaiter(_this, void 0, void 0, function () {
                    var promise, wrappedTrade, err_1;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                promise = provider.calculate(from, to, providersOptions);
                                _b.label = 1;
                            case 1:
                                _b.trys.push([1, 3, , 4]);
                                return [4 /*yield*/, (0, p_timeout_1.default)(promise, providersOptions.timeout)];
                            case 2:
                                wrappedTrade = _b.sent();
                                if (!wrappedTrade) {
                                    return [2 /*return*/, null];
                                }
                                return [2 /*return*/, __assign(__assign({}, wrappedTrade), { tradeType: type })];
                            case 3:
                                err_1 = _b.sent();
                                return [2 /*return*/, {
                                        trade: null,
                                        tradeType: type,
                                        error: err_1
                                    }];
                            case 4: return [2 /*return*/];
                        }
                    });
                });
            })));
            return tradeObservable$.pipe((0, rxjs_1.mergeMap)(function (el) { return el; }), (0, rxjs_1.map)(function (wrappedTrade) {
                providerData.calculatedProviders += 1;
                providerData.bestProvider = _this.chooseBestProvider(wrappedTrade, providerData.bestProvider);
                providerData.allProviders = wrappedTrade
                    ? __spreadArray(__spreadArray([], providerData.allProviders, true), [wrappedTrade], false) : providerData.allProviders;
                return providerData;
            }));
        }));
    };
    /**
     * Choose the best provider between two trades.
     * @param nextWrappedTrade New trade to compare.
     * @param prevWrappedTrade Old trade to compare.
     */
    CrossChainManager.prototype.chooseBestProvider = function (nextWrappedTrade, prevWrappedTrade) {
        var _a, _b;
        if ((prevWrappedTrade === null || prevWrappedTrade === void 0 ? void 0 : prevWrappedTrade.error) instanceof cross_chain_min_amount_error_1.CrossChainMinAmountError &&
            (nextWrappedTrade === null || nextWrappedTrade === void 0 ? void 0 : nextWrappedTrade.error) instanceof cross_chain_min_amount_error_1.CrossChainMinAmountError) {
            return prevWrappedTrade.error.minAmount.lte(nextWrappedTrade.error.minAmount)
                ? prevWrappedTrade
                : nextWrappedTrade;
        }
        if ((prevWrappedTrade === null || prevWrappedTrade === void 0 ? void 0 : prevWrappedTrade.error) instanceof cross_chain_max_amount_error_1.CrossChainMaxAmountError &&
            (nextWrappedTrade === null || nextWrappedTrade === void 0 ? void 0 : nextWrappedTrade.error) instanceof cross_chain_max_amount_error_1.CrossChainMaxAmountError) {
            return prevWrappedTrade.error.maxAmount.gte(nextWrappedTrade.error.maxAmount)
                ? prevWrappedTrade
                : nextWrappedTrade;
        }
        if (!prevWrappedTrade || prevWrappedTrade.error) {
            return nextWrappedTrade;
        }
        if (!nextWrappedTrade || nextWrappedTrade.error) {
            return prevWrappedTrade;
        }
        var prevTrade = prevWrappedTrade.trade;
        var fromUsd;
        if (prevTrade instanceof features_1.CelerRubicCrossChainTrade) {
            fromUsd = prevTrade.fromTrade.toToken.tokenAmount;
        }
        else if (prevTrade instanceof debridge_cross_chain_trade_1.DebridgeCrossChainTrade ||
            prevTrade instanceof features_1.SymbiosisCrossChainTrade) {
            fromUsd = prevTrade.transitAmount;
        }
        else if (prevTrade instanceof lifi_cross_chain_trade_1.LifiCrossChainTrade ||
            prevTrade instanceof via_cross_chain_trade_1.ViaCrossChainTrade) {
            fromUsd = prevTrade.from.price.multipliedBy(prevTrade.from.tokenAmount);
        }
        else {
            throw new rubic_sdk_error_1.RubicSdkError('Not supported trade');
        }
        var prevTradeRatio = (_a = prevWrappedTrade === null || prevWrappedTrade === void 0 ? void 0 : prevWrappedTrade.trade) === null || _a === void 0 ? void 0 : _a.getTradeAmountRatio(fromUsd);
        var nextTradeRatio = (_b = nextWrappedTrade === null || nextWrappedTrade === void 0 ? void 0 : nextWrappedTrade.trade) === null || _b === void 0 ? void 0 : _b.getTradeAmountRatio(fromUsd);
        if (!nextTradeRatio) {
            return prevWrappedTrade;
        }
        if (!prevTradeRatio) {
            return nextWrappedTrade;
        }
        return prevTradeRatio.lte(nextTradeRatio) ? prevWrappedTrade : nextWrappedTrade;
    };
    CrossChainManager.prototype.getFullOptions = function (options) {
        return (0, options_1.combineOptions)(options, {
            fromSlippageTolerance: CrossChainManager.defaultSlippageTolerance,
            toSlippageTolerance: CrossChainManager.defaultSlippageTolerance,
            gasCalculation: 'disabled',
            disabledProviders: [],
            timeout: CrossChainManager.defaultCalculationTimeout,
            providerAddress: this.providerAddress,
            slippageTolerance: CrossChainManager.defaultSlippageTolerance * 2,
            deadline: CrossChainManager.defaultDeadline
        });
    };
    CrossChainManager.prototype.calculateBestTradeFromTokens = function (from, to, options) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function () {
            var wrappedTrades, fromTokenPrice;
            var _this = this;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0: return [4 /*yield*/, this.calculateTradeFromTokens(from, to, this.getFullOptions(options))];
                    case 1:
                        wrappedTrades = _e.sent();
                        fromTokenPrice = ((_b = (_a = wrappedTrades.find(function (wrappedTrade) { return wrappedTrade.trade instanceof lifi_cross_chain_trade_1.LifiCrossChainTrade; })) === null || _a === void 0 ? void 0 : _a.trade) === null || _b === void 0 ? void 0 : _b.from.price) ||
                            ((_d = (_c = wrappedTrades.find(function (wrappedTrade) { return wrappedTrade.trade instanceof features_1.CelerCrossChainTrade; })) === null || _c === void 0 ? void 0 : _c.trade) === null || _d === void 0 ? void 0 : _d.fromTrade.toToken.tokenAmount);
                        if (!fromTokenPrice) {
                            return [2 /*return*/, wrappedTrades.sort(function (tradeA) { return ((tradeA === null || tradeA === void 0 ? void 0 : tradeA.trade) ? -1 : 1); })];
                        }
                        return [2 /*return*/, wrappedTrades.sort(function (firstTrade, secondTrade) {
                                var firstTradeRatio = _this.getProviderRatio(firstTrade, fromTokenPrice);
                                var secondTradeRatio = _this.getProviderRatio(secondTrade, fromTokenPrice);
                                return firstTradeRatio.comparedTo(secondTradeRatio);
                            })];
                }
            });
        });
    };
    CrossChainManager.prototype.getProviderRatio = function (wrappedTrade, fromTokenPrice) {
        var trade = wrappedTrade.trade;
        if (!trade || !fromTokenPrice || wrappedTrade.error) {
            return new bignumber_js_1.default(Infinity);
        }
        if (trade instanceof features_1.CelerCrossChainTrade) {
            return fromTokenPrice
                .plus(trade.cryptoFeeToken.price.multipliedBy(trade.cryptoFeeToken.tokenAmount))
                .dividedBy(trade.to.tokenAmount);
        }
        return fromTokenPrice.dividedBy(trade.to.tokenAmount);
    };
    CrossChainManager.prototype.calculateTradeFromTokens = function (from, to, options) {
        return __awaiter(this, void 0, void 0, function () {
            var disabledProviders, providersOptions, providers, calculationPromises, results;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        disabledProviders = options.disabledProviders, providersOptions = __rest(options, ["disabledProviders"]);
                        providers = Object.entries(this.tradeProviders).filter(function (_a) {
                            var type = _a[0];
                            if (disabledProviders.includes(type)) {
                                return false;
                            }
                            if (type === features_1.CROSS_CHAIN_TRADE_TYPE.RUBIC &&
                                celer_cross_chain_trade_provider_1.CelerCrossChainTradeProvider.isSupportedBlockchain(from.blockchain) &&
                                celer_cross_chain_trade_provider_1.CelerCrossChainTradeProvider.isSupportedBlockchain(to.blockchain)) {
                                return false;
                            }
                            return true;
                        });
                        if (!providers.length) {
                            throw new rubic_sdk_error_1.RubicSdkError("There are no providers for trade");
                        }
                        calculationPromises = providers.map(function (_a) {
                            var type = _a[0], provider = _a[1];
                            return __awaiter(_this, void 0, void 0, function () {
                                var calculation, wrappedTrade, err_2;
                                return __generator(this, function (_b) {
                                    switch (_b.label) {
                                        case 0:
                                            _b.trys.push([0, 2, , 3]);
                                            calculation = provider.calculate(from, to, providersOptions);
                                            return [4 /*yield*/, (0, p_timeout_1.default)(calculation, providersOptions.timeout)];
                                        case 1:
                                            wrappedTrade = _b.sent();
                                            if (!wrappedTrade) {
                                                return [2 /*return*/, null];
                                            }
                                            return [2 /*return*/, __assign(__assign({}, wrappedTrade), { tradeType: provider.type })];
                                        case 2:
                                            err_2 = _b.sent();
                                            console.debug("[RUBIC_SDK] Trade calculation error occurred for ".concat(type, " trade provider."), err_2);
                                            return [2 /*return*/, {
                                                    trade: null,
                                                    tradeType: provider.type,
                                                    error: cross_chain_trade_provider_1.CrossChainTradeProvider.parseError(err_2)
                                                }];
                                        case 3: return [2 /*return*/];
                                    }
                                });
                            });
                        });
                        return [4 /*yield*/, Promise.all(calculationPromises)];
                    case 1:
                        results = (_a.sent()).filter(object_1.notNull);
                        if (!(results === null || results === void 0 ? void 0 : results.length)) {
                            throw new rubic_sdk_error_1.RubicSdkError('No success providers calculation for the trade');
                        }
                        return [2 /*return*/, results];
                }
            });
        });
    };
    CrossChainManager.defaultCalculationTimeout = 25000;
    CrossChainManager.defaultSlippageTolerance = 0.02;
    CrossChainManager.defaultDeadline = 20;
    return CrossChainManager;
}());
exports.CrossChainManager = CrossChainManager;
//# sourceMappingURL=cross-chain-manager.js.map