import { RubicSdkError } from "../../common/errors/rubic-sdk.error";
import { BasicTransactionOptions } from "../../core/blockchain/models/basic-transaction-options";
import { PriceTokenAmount } from "../../core/blockchain/tokens/price-token-amount";
import { EncodeTransactionOptions } from "./models/encode-transaction-options";
import { GasFeeInfo } from "./models/gas-fee-info";
import { SwapTransactionOptions } from "./models/swap-transaction-options";
import { TransactionConfig } from 'web3-core';
import { TransactionReceipt } from 'web3-eth';
import { Web3Public } from "../../core/blockchain/web3-public/web3-public";
import { BlockchainName } from "../../core/blockchain/models/blockchain-name";
import { OptionsGasParams, TransactionGasParams } from "./models/gas-params";
import { TradeType } from "..";
import { Token, TransactionOptions } from "../../core";
import BigNumber from 'bignumber.js';
/**
 * Abstract class for all instant trade providers' trades.
 */
export declare abstract class InstantTrade {
    /**
     * Token to sell with input amount.
     */
    abstract readonly from: PriceTokenAmount;
    /**
     * Token to get with output amount.
     */
    abstract readonly to: PriceTokenAmount;
    /**
     * Gas fee info, including gas limit and gas price.
     */
    abstract gasFeeInfo: GasFeeInfo | null;
    /**
     * Slippage tolerance. Can be mutated after calculation, except for Zrx.
     */
    abstract slippageTolerance: number;
    protected abstract readonly contractAddress: string;
    protected readonly web3Public: Web3Public;
    /**
     * Type of instant trade provider.
     */
    abstract get type(): TradeType;
    abstract readonly path: ReadonlyArray<Token>;
    /**
     * Minimum amount of output token user can get.
     */
    get toTokenAmountMin(): PriceTokenAmount;
    protected get walletAddress(): string;
    /**
     * Price impact, based on tokens' usd prices.
     */
    get priceImpact(): number | null;
    protected constructor(blockchain: BlockchainName);
    /**
     * Returns true, if allowance is not enough.
     */
    needApprove(fromAddress?: string): Promise<boolean>;
    /**
     * Sends approve transaction with connected wallet.
     * @param options Transaction options.
     * @param checkNeedApprove If true, first allowance is checked.
     */
    approve(options: BasicTransactionOptions, checkNeedApprove?: boolean): Promise<TransactionReceipt>;
    /**
     * Build encoded approve transaction config.
     * @param tokenAddress Address of the smart-contract corresponding to the token.
     * @param spenderAddress Wallet or contract address to approve.
     * @param value Token amount to approve in wei.
     * @param [options] Additional options.
     * @returns Encoded approve transaction config.
     */
    encodeApprove(tokenAddress: string, spenderAddress: string, value: BigNumber | 'infinity', options?: TransactionOptions): Promise<TransactionConfig>;
    protected checkAllowanceAndApprove(options?: Omit<SwapTransactionOptions, 'onConfirm'>): Promise<void>;
    /**
     * Sends swap transaction with connected wallet.
     * If user has not enough allowance, then approve transaction will be called first.
     *
     * @example
     * ```ts
     * const onConfirm = (hash: string) => console.log(hash);
     * const receipt = await trades[TRADE_TYPE.UNISWAP_V2].swap({ onConfirm });
     * ```
     *
     * @param options Transaction options.
     */
    abstract swap(options?: SwapTransactionOptions): Promise<TransactionReceipt>;
    /**
     * Builds transaction config, with encoded data.
     * @param options Encode transaction options.
     */
    abstract encode(options: EncodeTransactionOptions): Promise<TransactionConfig>;
    protected checkWalletState(): Promise<void>;
    protected checkWalletConnected(): never | void;
    private checkBlockchainCorrect;
    protected getGasParams(options: OptionsGasParams): TransactionGasParams;
    protected parseError(err: unknown): RubicSdkError;
}
