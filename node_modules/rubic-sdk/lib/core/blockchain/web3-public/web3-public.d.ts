import { BlockchainName } from "../models/blockchain-name";
import { BatchCall } from "./models/batch-call";
import { ContractMulticallResponse } from "./models/contract-multicall-response";
import Web3 from 'web3';
import BigNumber from 'bignumber.js';
import { Transaction, provider as Provider, BlockNumber } from 'web3-core';
import { AbiItem } from 'web3-utils';
import { BlockTransactionString, TransactionReceipt } from 'web3-eth';
import { HttpClient } from "../../../common/models/http-client";
import { MethodData } from "./models/method-data";
import { EventData } from 'web3-eth-contract';
declare type SupportedTokenField = 'decimals' | 'symbol' | 'name' | 'totalSupply';
/**
 * Class containing methods for calling contracts in order to obtain information from the blockchain.
 * To send transaction or execute contract method use {@link Web3Private}.
 */
export declare class Web3Public {
    private readonly web3;
    private readonly blockchainName;
    private httpClient?;
    private multicallAddresses;
    private readonly clearController;
    /**
     * @param web3 Web3 instance initialized with ethereum provider, e.g. rpc link.
     * @param blockchainName Blockchain in which you need to execute requests.
     * @param [httpClient=axios] Http client that implements {@link HttpClient} interface.
     */
    constructor(web3: Web3, blockchainName: BlockchainName, httpClient?: HttpClient | undefined);
    /**
     * Health-check current rpc node.
     * @param timeoutMs Acceptable node response timeout.
     * @returns Null if healthcheck is not defined for current blockchain, else node health status.
     */
    healthCheck(timeoutMs?: number): Promise<boolean>;
    /**
     * Sets new provider to web3 instance.
     * @param provider New web3 provider, e.g. rpc link.
     */
    setProvider(provider: Provider): void;
    /**
     * Gets block by block id.
     * @param [blockId] Block id: hash, number ... Default is 'latest'.
     * @returns Block by blockId parameter.
     */
    getBlock(blockId?: BlockNumber | string): Promise<BlockTransactionString>;
    /**
     * Gets last block number.
     * @returns Block number.
     */
    getBlockNumber(): Promise<number>;
    /**
     * Gets account native or ERC-20 token balance in wei.
     * @param address Wallet address, whose balance you want to find out.
     * @param tokenAddress Address of the smart-contract corresponding to the token,
     * {@link NATIVE_TOKEN_ADDRESS} is used as default.
     */
    getBalance(address: string, tokenAddress?: string): Promise<BigNumber>;
    /**
     * Gets ERC-20 tokens balance in wei.
     * @param tokenAddress Address of the smart-contract corresponding to the token.
     * @param address Wallet address, whose balance you want to find out.
     */
    getTokenBalance(address: string, tokenAddress: string): Promise<BigNumber>;
    /**
     * Predicts the volume of gas required to execute the contract method.
     * @param contractAbi Abi of smart-contract.
     * @param contractAddress Address of smart-contract.
     * @param methodName Method which execution gas limit is to be calculated.
     * @param methodArguments Arguments of the contract method.
     * @param fromAddress The address for which the gas calculation will be called.
     * @param value The value transferred for the call “transaction” in wei.
     * @returns Estimated gas limit.
     */
    getEstimatedGas(contractAbi: AbiItem[], contractAddress: string, methodName: string, methodArguments: unknown[], fromAddress: string, value?: string | BigNumber): Promise<BigNumber | null>;
    /**
     * Calculates the average price per unit of gas according to web3.
     * @returns Average gas price in wei.
     */
    getGasPrice(): Promise<string>;
    /**
     * Calculates the average price per unit of gas according to web3.
     * @returns Average gas price with decimals.
     */
    getGasPriceInETH(): Promise<BigNumber>;
    /**
     * Calls allowance method in ERC-20 token contract.
     * @param tokenAddress Address of the smart-contract corresponding to the token.
     * @param spenderAddress Wallet or contract address, allowed to spend.
     * @param ownerAddress Wallet address to spend from.
     * @returns Token's amount, allowed to be spent.
     */
    getAllowance(tokenAddress: string, ownerAddress: string, spenderAddress: string): Promise<BigNumber>;
    /**
     * Gets mined transaction
     * @param hash transaction hash
     */
    getTransactionReceipt(hash: string): Promise<TransactionReceipt>;
    /**
     * Gets a transaction by hash in several attempts.
     * @param hash Hash of the target transaction.
     * @param attempt Current attempt number.
     * @param attemptsLimit Maximum allowed number of attempts.
     * @param delay Delay before next attempt in ms.
     */
    getTransactionByHash(hash: string, attempt?: number, attemptsLimit?: number, delay?: number): Promise<Transaction | null>;
    /**
     * Calls pure method of smart-contract and returns its output value.
     * @param contractAddress Address of smart-contract which method is to be executed.
     * @param contractAbi Abi of smart-contract which method is to be executed.
     * @param methodName Called method name.
     * @param [options] Additional options.
     * @param [options.from] The address the call should be made from.
     * @param [options.methodArguments] Method arguments.
     * @param [options.value] Native token amount to be passed.
     */
    callContractMethod<T = string>(contractAddress: string, contractAbi: AbiItem[], methodName: string, options?: {
        methodArguments?: unknown[];
        from?: string;
        value?: string;
    }): Promise<T>;
    /**
     * Gets balances of multiple tokens via multicall.
     * @param address Wallet address, which contains tokens.
     * @param tokensAddresses Tokens addresses.
     */
    getTokensBalances(address: string, tokensAddresses: string[]): Promise<BigNumber[]>;
    /**
     * Uses multicall to make several calls of one method in one contract.
     * @param contractAddress Target contract address.
     * @param contractAbi Target contract abi.
     * @param methodName Method name.
     * @param methodCallsArguments Method parameters array, for each method call.
     */
    multicallContractMethod<Output>(contractAddress: string, contractAbi: AbiItem[], methodName: string, methodCallsArguments: unknown[][]): Promise<ContractMulticallResponse<Output>[]>;
    /**
     * Uses multicall to make several methods calls in one contract.
     * @param contractAddress Target contract address.
     * @param contractAbi Target contract abi.
     * @param methodsData Methods data, containing methods' names and arguments.
     */
    multicallContractMethods<Output>(contractAddress: string, contractAbi: AbiItem[], methodsData: MethodData[]): Promise<ContractMulticallResponse<Output>[]>;
    /**
     * Uses multicall to make many methods calls in several contracts.
     * @param contractAbi Target contract abi.
     * @param contractsData Contract addresses and methods data, containing methods' names and arguments.
     */
    multicallContractsMethods<Output>(contractAbi: AbiItem[], contractsData: {
        contractAddress: string;
        methodsData: MethodData[];
    }[]): Promise<ContractMulticallResponse<Output>[][]>;
    /**
     * Checks if the specified address contains the required amount of these tokens.
     * Throws an InsufficientFundsError if balance is insufficient.
     * @param token Token, which balance you need to check.
     * @param amount Required balance.
     * @param userAddress The address, where the required balance should be.
     */
    checkBalance(token: {
        address: string;
        symbol: string;
        decimals: number;
    }, amount: BigNumber, userAddress: string): Promise<void>;
    /**
     * Gets ERC-20 token info by address.
     * @param tokenAddress Address of token.
     * @param tokenFields Token's fields to get.
     */
    callForTokenInfo(tokenAddress: string, tokenFields?: SupportedTokenField[]): Promise<Partial<Record<SupportedTokenField, string>>>;
    /**
     * Gets ERC-20 tokens info by addresses.
     * @param tokenAddresses Addresses of tokens.
     */
    callForTokensInfo(tokenAddresses: string[] | ReadonlyArray<string>): Promise<Record<SupportedTokenField, string | undefined>[]>;
    /**
     * Get estimated gas of several contract method executions via rpc batch request.
     * @param abi Contract ABI.
     * @param contractAddress Contract address.
     * @param fromAddress Sender address.
     * @param callsData Transactions parameters.
     * @returns List of contract execution estimated gases.
     * If the execution of the method in the real blockchain would not be reverted,
     * then the list item would be equal to the predicted gas limit.
     * Else (if you have not enough balance, allowance ...) then the list item would be equal to null.
     */
    batchEstimatedGas(abi: AbiItem[], contractAddress: string, fromAddress: string, callsData: BatchCall[]): Promise<(BigNumber | null)[]>;
    /**
     * Sends batch request to rpc provider directly.
     * @see {@link https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=false&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false|EthereumJSON-RPC}
     * @param rpcCallsData Rpc methods and parameters list.
     * @returns Rpc batch request call result sorted in order of input parameters.
     */
    private rpcBatchRequest;
    /**
     * Executes multiple calls in the single contract call.
     * @param calls Multicall calls data list.
     * @returns Result of calls execution.
     */
    private multicall;
    /**
     * Returns httpClient if it exists or imports the axios client.
     */
    private getHttpClient;
    getPastEvents(contractAddress: string, contractAbi: AbiItem[], eventName: string, options: {
        blocksAmount: number;
        toBlock: number | 'latest';
    }): Promise<EventData[]>;
}
export {};
